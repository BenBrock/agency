#include <future>
#include <utility>
#include <vector>
#include <barrier>
#include <functional>
#include <type_traits>
#include <exception_list>
#include "tuple_tail.hpp"


namespace std
{


template<class ExecutionGroup, class OtherChild>
struct __rebind_execution_group
{
  typedef typename ExecutionGroup::template rebind<OtherChild>::other type;
};


template<template<class, class, class...> class ExecutionGroup, class ExecutionPolicy, class OriginalChild, class... T, class OtherChild>
struct __rebind_execution_group<ExecutionGroup<ExecutionPolicy,OriginalChild, T...>, OtherChild>
{
  typedef ExecutionGroup<ExecutionPolicy, OtherChild, T...> type;
};


template<typename T>
  struct __has_child_type
{
  typedef char yes_type;
  typedef int  no_type;
  template<typename S> static yes_type test(typename S::child_type *);
  template<typename S> static no_type  test(...);
  static bool const value = sizeof(test<T>(0)) == sizeof(yes_type);
  typedef std::integral_constant<bool, value> type;
};


template<typename T>
struct __child_type
{
  typedef typename T::child_type type;
};


template<typename T>
struct __identity
{
  typedef T type;
};


template<bool b, typename T, typename F>
struct __lazy_conditional;


template<typename T, typename F>
struct __lazy_conditional<true,T,F>
{
  typedef typename T::type type;
};


template<typename T, typename F>
struct __lazy_conditional<false,T,F>
{
  typedef typename F::type type;
};


template<class ExecutionGroup>
class execution_group_traits
{
  private:
    template<class T>
    static constexpr size_t depth_impl(T, std::false_type has_child)
    {
      return 0;
    }

    template<class T>
    static constexpr size_t depth_impl(T, std::true_type has_child)
    {
      return 1 + execution_group_traits<child_type>::depth;
    }

  public:
    typedef ExecutionGroup                                 group_type;
    typedef typename ExecutionGroup::param_type            param_type;
    typedef typename ExecutionGroup::size_type             size_type;

    typedef typename __lazy_conditional<
      __has_child_type<group_type>::value,
      __child_type<group_type>,
      __identity<void>
    >::type                                                child_type;

    // XXX consider renaming to nesting_depth or grouping_depth
    //     to emphasize that agents have depth 0
    // XXX alternatively, make it illegal to use execution_group_traits on non-groups
    constexpr static size_t depth = depth_impl(0, typename __has_child_type<group_type>::type());
    
    template<class OtherChild>
    using rebind_execution_group = typename __rebind_execution_group<group_type, OtherChild>::type;

    template<class ParamTuple, class IndexTuple>
    static group_type make(const ParamTuple& params, const IndexTuple& indices)
    {
      return group_type(params, indices);
    }

    template<class OtherChild>
    static rebind_execution_group<OtherChild> rebind_child(const group_type& g, OtherChild&& child)
    {
      return rebind_execution_group<OtherChild>(g.param(), g.index(), std::move(child));
    }

    // XXX rethink whether we need both reindex and something which links two groups, possibly with new indices
    // XXX shouldn't we reindex the entire tree at the same time?
    // XXX shouldn't we recieve a tuple like make()?
    static void reindex(group_type& g, size_type new_index)
    {
      g.reindex(new_index);
    }

    class range_type
    {
      public:
        range_type(size_type b, size_type e) : begin_(b), end_(e) {}
        size_type begin() const { return begin_; }
        size_type end() const { return end_; }

      private:
        size_type begin_, end_;
    };

    static range_type range(const param_type &params)
    {
      return range_type{params.begin(), params.end()};
    }
};


class agent
{
  public:
    struct param_type {};
    typedef size_t size_type;

    // XXX is size() necessary?
    //     I don't think we ever use it
    size_type size() const { return 1; }

    size_type index() const { return index_; }

    agent(agent&& other) = default;

    param_type param() const
    {
      return param_type();
    }

  private:
    friend class execution_group_traits<agent>;

    agent(const std::tuple<param_type>&, const std::tuple<size_type>& index)
      : index_(std::get<0>(index))
    {}

    void reindex(size_type index)
    {
      index_ = index;
    }

    size_type index_;
};


// XXX eliminate ExecutionPolicy parameter; it is never used
template<class ExecutionPolicy, class ExecutionGroup>
class execution_group
{
  public:
    typedef ExecutionGroup                                         child_type;
    typedef typename execution_group_traits<child_type>::size_type size_type;
    typedef ExecutionPolicy                                        execution_policy_type;

    class param_type
    {
      public:
        param_type(const param_type& other)
          : param_type(other.begin(), other.end())
        {}

        param_type(size_type b, size_type e)
          : begin_(b), end_(e)
        {}

        param_type(size_type n)
          : begin_(0), end_(n)
        {}

        size_type begin() const
        {
          return begin_;
        }

        size_type end() const
        {
          return end_;
        }

      private:
        size_type begin_, end_;
    };

    param_type param() const
    {
      return param_type(indices_begin(), indices_end());
    }

    size_type indices_begin() const { return indices_begin_; }
    size_type indices_end() const { return indices_end_; }
    size_type size() const { return indices_end() - indices_begin(); }
    size_type index() const { return index_; }
    ExecutionGroup &child() { return child_; }
    const ExecutionGroup &child() const { return child_; }

  private:
    template<class> friend class execution_group_traits;

    size_type index_;
    size_type indices_begin_;
    size_type indices_end_;
    child_type child_;

    void reindex(size_type index)
    {
      index_ = index;
    }

  protected:
    typedef execution_group_traits<child_type> child_traits;

    template<class Param>
    execution_group(const Param& params, size_type index, child_type&& chld)
      : index_(index),
        indices_begin_(params.begin()),
        indices_end_(params.end()),
        child_(std::move(chld))
    {}

    template<class ParamTuple, class IndexTuple>
    execution_group(const ParamTuple& params, const IndexTuple& indices)
      : execution_group(std::get<0>(params),
                        std::get<0>(indices),
                        child_traits::make(tuple_tail(params), tuple_tail(indices)))
    {}
};


class sequential_execution_policy;


template<class ExecutionGroup>
using basic_sequential_group = execution_group<std::sequential_execution_policy, ExecutionGroup>;
typedef basic_sequential_group<agent> sequential_group;


class parallel_execution_policy;


template<class ExecutionGroup>
using basic_parallel_group = execution_group<std::parallel_execution_policy, ExecutionGroup>;
typedef basic_parallel_group<agent> parallel_group;


class concurrent_execution_policy;


template<class ExecutionGroup>
class basic_concurrent_group : public execution_group<std::concurrent_execution_policy, ExecutionGroup>
{
  private:
    typedef execution_group<std::concurrent_execution_policy, ExecutionGroup> super_t;

  public:
    typedef typename super_t::size_type size_type;

    class param_type : public super_t::param_type
    {
      public:
        param_type(size_type begin, size_type end, std::reference_wrapper<std::barrier> barrier)
          : super_t::param_type(begin,end),
            barrier_(barrier)
        {}

        param_type(size_type n, std::reference_wrapper<std::barrier> barrier)
          : param_type(0, n, barrier)
        {}

        param_type(const param_type &other)
          : param_type(other.begin(), other.end(), other.barrier())
        {}

        std::reference_wrapper<std::barrier> barrier() const
        {
          return barrier_;
        }

      private:
        std::reference_wrapper<std::barrier> barrier_;
    };

    param_type param() const
    {
      return param_type(super_t::indices_begin(), super_t::indices_end(), barrier_);
    }

    template<class OtherGroup>
    struct rebind
    {
      typedef basic_concurrent_group<OtherGroup> other;
    };

    // XXX consider making this function const
    void wait()
    {
      barrier_.count_down_and_wait();
    }

  private:
    template<class> friend class execution_group_traits;

    template<class ParamTuple, class IndexTuple>
    basic_concurrent_group(const ParamTuple& params, const IndexTuple& indices)
      : super_t(params, indices),
        barrier_(std::get<0>(params).barrier())
    {}

    template<class Param>
    basic_concurrent_group(const Param& params, size_type index, ExecutionGroup&& chld)
      : super_t(params, index, std::move(chld)),
        barrier_(params.barrier())
    {}

    std::barrier &barrier_;
};


typedef basic_concurrent_group<agent> concurrent_group;


template<class T>
struct __has_child_impl
{
  typedef char yes_type;
  struct no_type {char x[2];};

  template<class U> static yes_type test(decltype(&U::child));
  template<class U> static no_type  test(...);

  public:
    const static bool value = sizeof(test<T>(0)) == sizeof(yes_type);
};


template<class T>
struct __has_child :
  std::integral_constant<
    bool,
    __has_child_impl<T>::value
  >
{};


// XXX we shouldn't recursively create child_
// XXX instead a new execution_view should be created on demand inside the child() function
// XXX using a type erasure idiom
class execution_view
{
  public:
    typedef size_t size_type;

    inline execution_view(const execution_view &g)
      : index_(g.index_),
        size_(g.size_),
        self_(g.self_),
        child_(g.child_ ? new execution_view(g.child()) : nullptr)
    {}

    inline execution_view(execution_view &&g) = default;

    template<typename ExecutionGroup>
    execution_view(ExecutionGroup& g,
                   typename std::enable_if<__has_child<ExecutionGroup>::value>::type* = 0)
      : index_(g.index()),
        size_(g.size()),
        self_(&g),
        child_(new execution_view(g.child()))
    {}

    template<typename ExecutionGroup>
    execution_view(ExecutionGroup& g,
                   typename std::enable_if<!__has_child<ExecutionGroup>::value>::type* = 0)
      : index_(g.index()),
        size_(g.size()),
        self_(&g),
        child_()
    {}

    inline execution_view &operator=(execution_view &&g) = default;

    inline execution_view &operator=(const execution_view &g)
    {
      index_ = g.index_;
      size_ = g.size_;
      self_ = g.self_;
      child_ = g.child_ ? std::unique_ptr<execution_view>(new execution_view(g.child())) : nullptr;
      return *this;
    }

    template<typename ExecutionGroup>
    typename std::enable_if<
      __has_child<ExecutionGroup>::value,
      execution_view &
    >::type
      operator=(ExecutionGroup& g)
    {
      index_ = g.index();
      size_ = g.size();
      self_ = g.self_;
      *child_ = g.child();
    }

    template<typename ExecutionGroup>
    typename std::enable_if<
      !__has_child<ExecutionGroup>::value,
      execution_view &
    >::type
      operator=(ExecutionGroup& g)
    {
      index_ = g.index();
      size_ = g.size();
      self_ = g.self_;
      child_ = nullptr;
    }

    inline size_type size() const
    {
      return size_;
    }

    // XXX could rename this to rank() to distinguish betwen 1D rank and ND index
    inline size_type index() const
    {
      return index_;
    }

    // XXX i don't like the name child
    inline execution_view child()
    {
      return child_ ? *child_ : *this;
    }

    // XXX i don't like the name child
    const execution_view child() const
    {
      return child_ ? *child_ : *this;
    }

  private:
    // allow empty execution_view for this_group() below
    inline execution_view(std::nullptr_t)
      : index_(0),
        size_(0),
        self_(nullptr),
        child_(nullptr)
    {}

    friend execution_view &this_group();

    size_type index_;
    size_type size_;
    void *self_;
    std::unique_ptr<execution_view> child_;
};


// XXX implement these later
//// cast execution_group to a particular type of ExecutionGroup
//// throws if typeof() doesn't match
//template<typename ExecutionGroup>
//ExecutionGroup &get(execution_group &g);
//
//
//// cast execution_group to a particular type of ExecutionGroup
//template<typename ExecutionGroup>
//const ExecutionGroup &get(const execution_group &g);


// XXX this should return a value created on demand
inline execution_view &this_group()
{
  // XXX this should be initialized to a sequential_group with a single agent executing in this_thread
  static thread_local execution_view current{nullptr};
  return current;
}


inline execution_view __set_this_group(const execution_view &g)
{
  execution_view old_group = this_group();
  this_group() = g;
  return old_group;
}


inline execution_view __set_this_group(execution_view &&g)
{
  execution_view old_group = this_group();
  this_group() = std::move(g);
  return old_group;
}


class __scoped_group
{
  public:
    template<class ExecutionGroup>
    __scoped_group(ExecutionGroup &this_group)
       : old_group_(__set_this_group(this_group))
    {}

    inline ~__scoped_group()
    {
      // restore old group
      __set_this_group(std::move(old_group_));
    }

  private:
    execution_view old_group_;
};


class __integer_range
{
  public:
    __integer_range(size_t b, size_t e)
      : begin_(b), end_(e)
    {}

    inline size_t size() const
    {
      return end() - begin();
    }

    inline size_t begin() const
    {
      return begin_;
    }

    inline size_t end() const
    {
      return end_;
    }

    inline bool contains(size_t x) const
    {
      return begin() <= x && x < end();
    }

    inline friend std::ostream &operator<<(std::ostream &os, const __integer_range &rng)
    {
      os << "[" << rng.begin() << ", " << rng.end() << ")";
      return os;
    }

  private:
    size_t begin_, end_;
};


// XXX add is_execution_policy_v
template<class T> struct is_execution_policy : std::false_type {};


template<class OuterPolicy, class InnerPolicy>
struct __nested_execution_policy
{
  OuterPolicy outer_exec;
  InnerPolicy inner_exec;
};


template<class T1, class T2>
struct is_execution_policy<__nested_execution_policy<T1,T2>>
  : std::integral_constant<
      bool,
      is_execution_policy<T1>::value && is_execution_policy<T2>::value
    >
{};


template<class OuterPolicy, class InnerPolicy>
__nested_execution_policy<OuterPolicy,InnerPolicy> __make_nested(const OuterPolicy outer, const InnerPolicy &inner)
{
  return __nested_execution_policy<OuterPolicy,InnerPolicy>{outer,inner};
}


template<class... Types>
struct __last_type_impl
{
  typedef typename std::tuple_element<sizeof...(Types) - 1, std::tuple<Types...>>::type type;
};


template<>
struct __last_type_impl<>
{
  typedef void type;
};


template<class... Types>
using __last_type = typename __last_type_impl<Types...>::type;


template<class Result, class... Args>
struct __enable_if_nested_call
  : std::enable_if<
      is_execution_policy<__last_type<Args...>>::value,
      Result
    >
{};


template<class Result, class... Args>
struct __disable_if_nested_call
  : std::enable_if<
      !is_execution_policy<__last_type<Args...>>::value,
      Result
    >
{};


template<class,class> class __grouped_execution_policy;


template<class ExecutionPolicy, class FlatExecutionGroup>
struct is_execution_policy<__grouped_execution_policy<ExecutionPolicy,FlatExecutionGroup>>
  : is_execution_policy<ExecutionPolicy>
{};


template<class ExecutionPolicy, class FlatExecutionGroup>
class __grouped_execution_policy
{
  public:
    static_assert(is_execution_policy<ExecutionPolicy>::value == true, "__grouped_execution_policy's ExecutionPolicy parameter must be an execution policy type.");
    static_assert(execution_group_traits<FlatExecutionGroup>::depth == 1, "__grouped_execution_policy's execution group must be flat (have depth == 1).");

    typedef FlatExecutionGroup                                      group_type;
    typedef typename execution_group_traits<group_type>::child_type agent_type;

    typedef typename execution_group_traits<group_type>::param_type group_param_type;
    typedef typename execution_group_traits<agent_type>::param_type agent_param_type;

    __grouped_execution_policy(const __grouped_execution_policy& other)
      : params_(other.params_)
    {}

    __grouped_execution_policy(const group_param_type& group_params, const agent_param_type& agent_params = agent_param_type())
      : params_(group_params, agent_params)
    {}

    const std::tuple<group_param_type,agent_param_type> &params() const
    {
      return params_;
    }

    template<class OtherFlatExecutionGroup, class... Args>
    __grouped_execution_policy<ExecutionPolicy,OtherFlatExecutionGroup> make(Args&&... args) const
    {
      typedef typename __grouped_execution_policy<ExecutionPolicy,OtherFlatExecutionGroup>::group_param_type group_param_type;
      group_param_type group_params(std::forward<Args>(args)...);
      return __grouped_execution_policy<ExecutionPolicy,OtherFlatExecutionGroup>(group_params);
    }

  private:
    std::tuple<group_param_type, agent_param_type> params_;
};


class sequential_execution_policy;


template<> struct is_execution_policy<sequential_execution_policy> : std::true_type {};
    

// XXX collapse all of this such that __grouped_execution_policy contains everything
class sequential_execution_policy : public __grouped_execution_policy<sequential_execution_policy,sequential_group>
{
  public:
    inline sequential_execution_policy(size_t n) : __grouped_execution_policy(sequential_group::param_type(n)) {}

    // this is the nested form of operator()
    template<class ExecutionPolicy>
    __nested_execution_policy<
      __grouped_execution_policy<sequential_execution_policy,sequential_group>,
      ExecutionPolicy
    > operator()(size_t n, ExecutionPolicy &&exec) const
    {
      return __make_nested(operator()(n), exec);
    }

    // only enable this operator() if the last parameter in (Arg1, Args...) is not an execution policy
    // this is the flat form of operator()
    template<class Arg1, class... Args>
    typename __disable_if_nested_call<
      __grouped_execution_policy<sequential_execution_policy,sequential_group>,
      Arg1, Args...
    >::type
    operator()(Arg1&& arg1, Args&&... args) const
    {
      return __grouped_execution_policy::make<sequential_group>(std::forward<Arg1>(arg1), std::forward<Args>(args)...);
    }
};


class parallel_execution_policy;


template<> struct is_execution_policy<parallel_execution_policy> : std::true_type {};


class parallel_execution_policy : public __grouped_execution_policy<parallel_execution_policy,parallel_group>
{
  public:
    inline parallel_execution_policy(size_t n) : __grouped_execution_policy(parallel_group::param_type(n)) {}

    // this is the nested form of operator()
    template<class ExecutionPolicy>
    __nested_execution_policy<
      __grouped_execution_policy<parallel_execution_policy,parallel_group>,
      ExecutionPolicy
    > operator()(size_t n, ExecutionPolicy &&exec) const
    {
      return __make_nested(operator()(n), exec);
    }

    // only enable this operator() if the last parameter in (Arg1, Args...) is not an execution policy
    // this is the flat form of operator()
    template<class Arg1, class... Args>
    typename __disable_if_nested_call<
      __grouped_execution_policy<parallel_execution_policy,parallel_group>,
      Arg1, Args...
    >::type
    operator()(Arg1&& arg1, Args&&... args) const
    {
      return __grouped_execution_policy::make<parallel_group>(std::forward<Arg1>(arg1), std::forward<Args>(args)...);
    }
};


class concurrent_execution_policy;


template<> struct is_execution_policy<concurrent_execution_policy> : std::true_type {};


class concurrent_execution_policy
{
  public:
    inline concurrent_execution_policy(size_t n) : rng{0,n} {}

    template<class ExecutionPolicy>
    __nested_execution_policy<concurrent_execution_policy, ExecutionPolicy> operator()(size_t n, ExecutionPolicy &&exec) const
    {
      return __make_nested(operator()(n), exec);
    }

    inline concurrent_execution_policy operator()(size_t n) const
    {
      return concurrent_execution_policy(n);
    }

    template<class FlatExecutionGroup, class... Args>
    __grouped_execution_policy<concurrent_execution_policy,FlatExecutionGroup> make(Args&&... args) const
    {
      typedef typename __grouped_execution_policy<concurrent_execution_policy,FlatExecutionGroup>::group_param_type group_param_type;
      group_param_type group_params(std::forward<Args>(args)...);
      return __grouped_execution_policy<concurrent_execution_policy,FlatExecutionGroup>(group_params);
    }

//  private:
    __integer_range rng;
};


//constexpr sequential_execution_policy seq{0};
//constexpr parallel_execution_policy   par{0};
//constexpr concurrent_execution_policy con{0};
const sequential_execution_policy seq{0};
const parallel_execution_policy   par{0};
const concurrent_execution_policy con{0};


template<class FlatExecutionGroup, class Function, class... Args>
void sync(const __grouped_execution_policy<sequential_execution_policy,FlatExecutionGroup> &exec, Function f, Args&&... args)
{
  exception_list exceptions;

  try
  {
    typedef execution_group_traits<FlatExecutionGroup> traits;
    typedef typename traits::child_type                agent_type;

    auto this_group = traits::make(exec.params(), std::make_tuple(0, 0));
    agent_type& this_agent = this_group.child();

    __scoped_group scope(this_group);

    // execute agents sequentially
    auto rng = traits::range(std::get<0>(exec.params()));
    for(auto agent_idx = rng.begin();
        agent_idx < rng.end();
        ++agent_idx)
    {
      // reindex the current agent
      execution_group_traits<agent_type>::reindex(this_agent, agent_idx);

      f(this_group, args...);
    }
  } // end try
  catch(...)
  {
    __add_current_exception(exceptions);
    throw exceptions;
  } // end catch
}


template<class FlatExecutionGroup, class Function, class... Args>
future<void> __async(const __grouped_execution_policy<sequential_execution_policy,FlatExecutionGroup> &exec, Function f, Args&&... args)
{
  // XXX could generalize the launch policy to allow concurrent_execution_policy to make use of this
  return std::async(std::launch::deferred, [=](Args&&... args)
  {
    std::sync(exec, f, std::forward<Args>(args)...);
  });
}


template<class ExecutionGroup>
class __subgroup
{
  public:
    typedef execution_group_traits<ExecutionGroup> parent_traits;
    typedef typename parent_traits::param_type     parent_param_type;
    typedef typename parent_traits::size_type      size_type;
    typedef typename parent_traits::child_type     child_type;

    class param_type
    {
      public:
        param_type(size_type begin, size_type end, const parent_param_type &parent_params)
          : begin_(begin),
            end_(end),
            parent_params_(parent_params)
        {}

        size_type begin() const
        {
          return begin_;
        }

        size_type end() const
        {
          return end_;
        }

        const parent_param_type &parent_params() const
        {
          return parent_params_;
        }

      private:
        size_type begin_, end_;
        parent_param_type parent_params_;
    };

    template<class ParamTuple, class IndexTuple>
    __subgroup(size_type begin, size_type end, const ParamTuple& parent_params, const IndexTuple& indices)
      : indices_begin_(begin),
        indices_end_(end),
        group_(parent_traits::make(parent_params, indices))
    {}

    // tease __subgroup's params out of the ParamTuple's first element
    // and forward everything along to the other constructor
    template<class ParamTuple, class IndexTuple>
    __subgroup(const ParamTuple& params, const IndexTuple& indices)
      : __subgroup(std::get<0>(params).begin(),
                   std::get<0>(params).end(),
                   params,
                   indices)
    {}

    param_type param() const
    {
      return param_type(indices_begin(), indices_end(), group().param());
    }

    size_type indices_begin() const
    {
      return indices_begin_;
    }

    size_type indices_end() const
    {
      return indices_end_;
    }

    size_type size() const
    {
      return indices_end() - indices_begin();
    }

    ExecutionGroup &group()
    {
      return group_;
    }

    const ExecutionGroup &group() const
    {
      return group_;
    }

    size_type index() const
    {
      return group().index();
    }

    child_type &child()
    {
      return group().child();
    }

  private:
    size_type indices_begin_;
    size_type indices_end_;
    ExecutionGroup group_;
};


// declare ExecutionPolicy-based async for the functions below
template<class ExecutionPolicy, class Function, class... Args>
typename std::enable_if<
  is_execution_policy<ExecutionPolicy>::value,
  std::future<void>
>::type
async(ExecutionPolicy&& exec, Function&& f, Args&&... args);


template<class FlatExecutionGroup, class Function, class... Args>
void sync(const __grouped_execution_policy<concurrent_execution_policy,FlatExecutionGroup> &exec, Function f, Args&&... args)
{
  typedef execution_group_traits<FlatExecutionGroup> traits;
  
  auto rng = traits::range(std::get<0>(exec.params()));
  
  std::vector<std::future<void>> futures(rng.end() - rng.begin());
  
  // launch agents
  // XXX could we use the __subgroup idiom here?
  for(auto agent_idx = rng.begin();
      agent_idx < rng.end();
      ++agent_idx)
  {
    // XXX could call std::async(seq) here with a subgroup if async(seq)'s launch policy was generalized
    futures[agent_idx] = std::async(std::launch::async, [=](Args&&... args)
    {
      auto this_group = traits::make(exec.params(), std::make_tuple(0, agent_idx));
  
      __scoped_group scope(this_group);
  
      f(this_group, args...);
    },
    std::forward<Args>(args)...);
  }
  
  __flatten_and_throw_exceptions(futures.begin(), futures.end());
}


template<class Function, class... Args>
void sync(const concurrent_execution_policy &exec, Function f, Args&&... args)
{
  __integer_range rng = exec.rng.size() > 0 ? exec.rng : __integer_range{0,1};
  
  // create a barrier
  std::barrier barrier(rng.end() - rng.begin());
  
  auto group_params = concurrent_group::param_type(rng.begin(),rng.end(),barrier);
  typedef __grouped_execution_policy<concurrent_execution_policy,concurrent_group> policy_type;
  
  policy_type grouped_policy(group_params);
  
  std::sync(grouped_policy, f, std::forward<Args>(args)...);
}


template<class FlatExecutionGroup, class Function, class... Args>
future<void> __async(const __grouped_execution_policy<concurrent_execution_policy,FlatExecutionGroup> &exec, Function f, Args&&... args)
{
  return std::async(std::launch::async, [=](Args&&... args)
  {
    std::sync(exec, f, std::forward<Args>(args)...);
  },
  std::forward<Args>(args)...);
}


template<class Function, class... Args>
std::future<void> __async(const concurrent_execution_policy &exec, Function f, Args&&... args)
{
  return std::async(std::launch::async, [=](Args&&... args)
  {
    std::sync(exec, f, std::forward<Args>(args)...);
  },
  std::forward<Args>(args)...);
}


inline unsigned int __log2(unsigned int x)
{
  unsigned int result = 0;
  while(x >>= 1) ++result;
  return result;
}


template<class FlatExecutionGroup, class Function, class... Args>
future<void> __async(const __grouped_execution_policy<parallel_execution_policy,FlatExecutionGroup> &exec, Function f, Args&&... args)
{
  typedef execution_group_traits<FlatExecutionGroup> traits;
  typedef typename traits::size_type                 size_type;

  auto group_params = std::get<0>(exec.params());

  auto rng = traits::range(group_params);
  auto group_size = rng.end() - rng.begin();

  const size_type min_num_agents_per_launch = 1000;
  size_type num_concurrent_agents = (group_size + min_num_agents_per_launch - 1) / min_num_agents_per_launch;
  const size_type subscription = std::max(1u, __log2(std::min(1u,std::thread::hardware_concurrency())));

  num_concurrent_agents = std::min<size_t>(subscription * std::thread::hardware_concurrency(), num_concurrent_agents);
  const size_type num_seq_agents_per_concurrent = (group_size + num_concurrent_agents - 1) / num_concurrent_agents;

  return std::async(std::con.make<parallel_group>(num_concurrent_agents), [=](parallel_group &g, Args&&... args)
  {
    auto subgroup_begin = g.child().index() * num_seq_agents_per_concurrent;
    auto subgroup_end   = std::min(group_size, subgroup_begin + num_seq_agents_per_concurrent);

    std::sync(std::seq.make<__subgroup<FlatExecutionGroup>>(subgroup_begin, subgroup_end, group_params), [=](__subgroup<FlatExecutionGroup> &subgroup, Args&&... args)
    {
      f(subgroup.group(), args...);
    },
    std::forward<Args>(args)...);
  },
  std::forward<Args>(args)...);
}


template<class FlatExecutionGroup, class Function, class... Args>
void sync(const __grouped_execution_policy<parallel_execution_policy,FlatExecutionGroup> &exec, Function f, Args&&... args)
{
  return std::async(exec, std::forward<Function>(f), std::forward<Args>(args)...).wait();
}


template<class OuterPolicy, class InnerPolicy, class Function>
struct __async_outer_functor
{
  template<class OuterGroup, class Index>
  struct inner_functor
  {
    OuterGroup &outer_group;
    Function f;
    Index inner_idx;

    template<class InnerGroup, class... Args>
    void operator()(InnerGroup& inner_group, Args&&... args) const
    {
      // reindex the inner group
      execution_group_traits<InnerGroup>::reindex(inner_group, inner_idx);

      // create a new group by rebinding the outer group's child
      auto rebound_group = execution_group_traits<OuterGroup>::rebind_child(outer_group, std::move(inner_group));

      __scoped_group scope(rebound_group);

      // call f
      f(rebound_group, args...);
    }
  };

  __nested_execution_policy<OuterPolicy,InnerPolicy> exec_args;
  Function f;

  template<class OuterGroup, class... Args>
  void operator()(OuterGroup& outer_group, Args&&... args) const
  {
    typedef typename execution_group_traits<OuterGroup>::size_type size_type;

    async(exec_args.inner_exec, inner_functor<OuterGroup,size_type>{outer_group, f, outer_group.child().index()}, args...).wait();
  }
};


template<class OuterPolicy, class InnerPolicy, class Function, class... Args>
std::future<void> __async(const __nested_execution_policy<OuterPolicy,InnerPolicy> &exec_args, Function f, Args&&... args)
{
  // XXX use __async_outer_functor because gcc 4.8 has trouble with lambdas + parameter packs
  return std::async(exec_args.outer_exec, __async_outer_functor<OuterPolicy,InnerPolicy,Function>{exec_args,f}, args...);
}


template<class ExecutionPolicy, class Function, class... Args>
typename std::enable_if<
  is_execution_policy<ExecutionPolicy>::value,
  std::future<void>
>::type
async(ExecutionPolicy&& exec, Function&& f, Args&&... args)
{
  return __async(std::forward<ExecutionPolicy>(exec), std::forward<Function>(f), std::forward<Args>(args)...);
}


} // end std

