#include <future>
#include <utility>
#include <vector>
#include <barrier>
#include <functional>
#include <type_traits>
#include <exception_list>
#include "make_from_tuple.hpp"

// For our purposes, an ExecutionGroup is a type with the following member types:
//
// size_type
//
// And the following member functions:
//
// size_type size() const;
// size_type index() const;
//
// A ConcurrentGroup is an ExecutionGroup with the following member function:
//
// void wait();
//
// An ExecutionAgent is a ParallelGroup whose member function size() always returns 1.


namespace std
{


class agent
{
  public:
    typedef size_t size_type;

    size_type size() const { return 1; }
    size_type index() const { return index_; }

//  private:
    agent(size_type idx = 0)
      : index_(idx)
    {}

    size_type index_;
};


// XXX eliminate ExecutionPolicy parameter; it is never used
template<class ExecutionPolicy, class ExecutionGroup>
class execution_group
{
  public:
    typedef size_t          size_type;
    typedef ExecutionPolicy execution_policy_type;
    typedef ExecutionGroup  child_type;

    class param_type
    {
      public:
        param_type(size_type b, size_type e)
          : begin_(b), end_(e)
        {}

        size_type begin() const
        {
          return begin_;
        }

        size_type end() const
        {
          return end_;
        }

      private:
        size_type begin_, end_;
    };

    size_type indices_begin() const { return indices_begin_; }
    size_type indices_end() const { return indices_end_; }
    size_type size() const { return indices_end() - indices_begin(); }
    size_type index() const { return index_; }
    ExecutionGroup &child() { return child_; }
    const ExecutionGroup &child() const { return child_; }

//  private:
    size_type index_;
    size_type indices_begin_;
    size_type indices_end_;
    child_type child_;

    execution_group(size_type begin, size_type end, child_type &&chld = child_type())
      : index_(0),
        indices_begin_(begin),
        indices_end_(end),
        child_(std::move(chld))
    {}

    execution_group(const param_type &params, child_type &&chld = child_type())
      : execution_group(params.begin(),
                        params.end(),
                        std::move(chld))
    {}

    // move constructor which can perform reindexing at the same 
    execution_group(size_type idx, execution_group &&other)
      : index_(idx),
        indices_begin_(other.indices_begin_),
        indices_end_(other.indices_end_),
        child_(std::move(other.child_))
    {}

    // moves the resources associated with other except for other's child
    // this sequential_group's child is created by moving the second argument
    // only the implementation may do this
    template<class OtherGroup>
    execution_group(execution_group<ExecutionPolicy, OtherGroup> &&other, child_type &&chld)
      : index_(other.index_),
        indices_begin_(other.indices_begin_),
        indices_end_(other.indices_end_),
        child_(std::move(chld))
    {}
};


class sequential_execution_policy;


template<class ExecutionGroup>
using basic_sequential_group = execution_group<std::sequential_execution_policy, ExecutionGroup>;
typedef basic_sequential_group<agent> sequential_group;


class parallel_execution_policy;


template<class ExecutionGroup>
using basic_parallel_group = execution_group<std::parallel_execution_policy, ExecutionGroup>;
typedef basic_parallel_group<agent> parallel_group;


class concurrent_execution_policy;


template<class ExecutionGroup>
class basic_concurrent_group : public execution_group<std::concurrent_execution_policy, ExecutionGroup>
{
  private:
    typedef execution_group<std::concurrent_execution_policy, ExecutionGroup> super_t;

  public:
    typedef typename super_t::size_type size_type;

    class param_type : public super_t::param_type
    {
      public:
        param_type(size_type begin, size_type end, std::reference_wrapper<std::barrier> barrier)
          : super_t::param_type(begin,end),
            barrier_(barrier)
        {}

        std::reference_wrapper<std::barrier> barrier() const
        {
          return barrier_;
        }

      private:
        std::reference_wrapper<std::barrier> barrier_;
    };

    template<class OtherGroup>
    struct rebind
    {
      typedef basic_concurrent_group<OtherGroup> other;
    };

    void wait()
    {
      barrier_.count_down_and_wait();
    }

//  private:
    basic_concurrent_group(size_type begin, size_type end, std::reference_wrapper<std::barrier> barrier, ExecutionGroup &&chld = ExecutionGroup())
      : super_t(begin, end, std::move(chld)),
        barrier_(barrier)
    {}

    basic_concurrent_group(const param_type &params, ExecutionGroup &&chld = ExecutionGroup())
      : basic_concurrent_group(params.begin(),params.end(),params.barrier(),std::move(chld))
    {}

    // move constructor which can perform reindexing at the same 
    basic_concurrent_group(size_type idx, basic_concurrent_group &&other)
      : super_t(idx, std::move(other)),
        barrier_(other.barrier_)
    {}

    // moves the resources associated with other except for other's child
    // this sequential_group's child is created by moving the second argument
    // only the implementation may do this
    template<class OtherGroup>
    basic_concurrent_group(basic_concurrent_group<OtherGroup> &&other, ExecutionGroup &&chld)
      : super_t(std::move(other), std::move(chld)),
        barrier_(other.barrier_)
    {}

  private:
    // friend other types of basic_concurrent_group so we can copy their barrier in the move constructor above
    template<class OtherGroup> friend class basic_concurrent_group;

    std::barrier &barrier_;
};


typedef basic_concurrent_group<agent> concurrent_group;


template<class ExecutionGroup, class OtherChild>
struct __rebind_execution_group
{
  typedef typename ExecutionGroup::template rebind<OtherChild>::other type;
};


template<template<class, class, class...> class ExecutionGroup, class ExecutionPolicy, class OriginalChild, class... T, class OtherChild>
struct __rebind_execution_group<ExecutionGroup<ExecutionPolicy,OriginalChild, T...>, OtherChild>
{
  typedef ExecutionGroup<ExecutionPolicy, OtherChild, T...> type;
};


// XXX perhaps all ExecutionGroups should friend their associated traits class
// XXX that would be a simple way to handle access
template<class ExecutionGroup>
class execution_group_traits
{
  public:
    typedef ExecutionGroup                                 group_type;
    typedef typename ExecutionGroup::param_type            param_type;
    typedef typename ExecutionGroup::child_type            child_type;
    typedef typename ExecutionGroup::size_type             size_type;
    
    template<class OtherChild>
    using rebind_execution_group = typename __rebind_execution_group<group_type, OtherChild>::type;

    // XXX eliminate this
    static size_type indices_begin(group_type &g)
    {
      return g.indices_begin();
    }

    // XXX eliminate this
    static size_type indices_end(group_type &g)
    {
      return g.indices_end();
    }

    template<class... Args>
    static group_type make(const param_type &params, Args&&... args)
    {
      return group_type(params, std::forward<Args>(args)...);
    }

    class range_type
    {
      public:
        range_type(size_type b, size_type e) : begin_(b), end_(e) {}
        size_type begin() const { return begin_; }
        size_type end() const { return end_; }

      private:
        size_type begin_, end_;
    };

    static range_type range(const param_type &params)
    {
      return range_type{params.begin(), params.end()};
    }
};


template<class T>
struct __has_child_impl
{
  typedef char yes_type;
  struct no_type {char x[2];};

  template<class U> static yes_type test(decltype(&U::child));
  template<class U> static no_type  test(...);

  public:
    const static bool value = sizeof(test<T>(0)) == sizeof(yes_type);
};


template<class T>
struct __has_child :
  std::integral_constant<
    bool,
    __has_child_impl<T>::value
  >
{};


// XXX we shouldn't recursively create child_
// XXX instead a new execution_view should be created on demand inside the child() function
// XXX using a type erasure idiom
class execution_view
{
  public:
    typedef size_t size_type;

    inline execution_view(const execution_view &g)
      : index_(g.index_),
        size_(g.size_),
        self_(g.self_),
        child_(g.child_ ? new execution_view(g.child()) : nullptr)
    {}

    inline execution_view(execution_view &&g) = default;

    template<typename ExecutionGroup>
    execution_view(ExecutionGroup& g,
                   typename std::enable_if<__has_child<ExecutionGroup>::value>::type* = 0)
      : index_(g.index()),
        size_(g.size()),
        self_(&g),
        child_(new execution_view(g.child()))
    {}

    template<typename ExecutionGroup>
    execution_view(ExecutionGroup& g,
                   typename std::enable_if<!__has_child<ExecutionGroup>::value>::type* = 0)
      : index_(g.index()),
        size_(g.size()),
        self_(&g),
        child_()
    {}

    inline execution_view &operator=(execution_view &&g) = default;

    inline execution_view &operator=(const execution_view &g)
    {
      index_ = g.index_;
      size_ = g.size_;
      self_ = g.self_;
      child_ = g.child_ ? std::unique_ptr<execution_view>(new execution_view(g.child())) : nullptr;
      return *this;
    }

    template<typename ExecutionGroup>
    typename std::enable_if<
      __has_child<ExecutionGroup>::value,
      execution_view &
    >::type
      operator=(ExecutionGroup& g)
    {
      index_ = g.index();
      size_ = g.size();
      self_ = g.self_;
      *child_ = g.child();
    }

    template<typename ExecutionGroup>
    typename std::enable_if<
      !__has_child<ExecutionGroup>::value,
      execution_view &
    >::type
      operator=(ExecutionGroup& g)
    {
      index_ = g.index();
      size_ = g.size();
      self_ = g.self_;
      child_ = nullptr;
    }

    inline size_type size() const
    {
      return size_;
    }

    // XXX could rename this to rank() to distinguish betwen 1D rank and ND index
    inline size_type index() const
    {
      return index_;
    }

    // XXX i don't like the name child
    inline execution_view child()
    {
      return child_ ? *child_ : *this;
    }

    // XXX i don't like the name child
    const execution_view child() const
    {
      return child_ ? *child_ : *this;
    }

  private:
    // allow empty execution_view for this_group() below
    inline execution_view(std::nullptr_t)
      : index_(0),
        size_(0),
        self_(nullptr),
        child_(nullptr)
    {}

    friend execution_view &this_group();

    size_type index_;
    size_type size_;
    void *self_;
    std::unique_ptr<execution_view> child_;
};


// XXX implement these later
//// cast execution_group to a particular type of ExecutionGroup
//// throws if typeof() doesn't match
//template<typename ExecutionGroup>
//ExecutionGroup &get(execution_group &g);
//
//
//// cast execution_group to a particular type of ExecutionGroup
//template<typename ExecutionGroup>
//const ExecutionGroup &get(const execution_group &g);


inline execution_view &this_group()
{
  // XXX this should be initialized to a sequential_group with a single agent executing in this_thread
  static thread_local execution_view current{nullptr};
  return current;
}


inline execution_view __set_this_group(const execution_view &g)
{
  execution_view old_group = this_group();
  this_group() = g;
  return old_group;
}


inline execution_view __set_this_group(execution_view &&g)
{
  execution_view old_group = this_group();
  this_group() = std::move(g);
  return old_group;
}


class __scoped_group
{
  public:
    template<class ExecutionGroup>
    __scoped_group(ExecutionGroup &this_group)
       : old_group_(__set_this_group(this_group))
    {}

    inline ~__scoped_group()
    {
      // restore old group
      __set_this_group(std::move(old_group_));
    }

  private:
    execution_view old_group_;
};


class __integer_range
{
  public:
    __integer_range(size_t b, size_t e)
      : begin_(b), end_(e)
    {}

    inline size_t size() const
    {
      return end() - begin();
    }

    inline size_t begin() const
    {
      return begin_;
    }

    inline size_t end() const
    {
      return end_;
    }

    inline bool contains(size_t x) const
    {
      return begin() <= x && x < end();
    }

    inline friend std::ostream &operator<<(std::ostream &os, const __integer_range &rng)
    {
      os << "[" << rng.begin() << ", " << rng.end() << ")";
      return os;
    }

  private:
    size_t begin_, end_;
};


template<class OuterPolicy, class InnerPolicy>
struct __nested_execution_policy
{
  OuterPolicy outer_exec;
  InnerPolicy inner_exec;
};


template<class OuterPolicy, class InnerPolicy>
__nested_execution_policy<OuterPolicy,InnerPolicy> __make_nested(const OuterPolicy outer, const InnerPolicy &inner)
{
  return __nested_execution_policy<OuterPolicy,InnerPolicy>{outer,inner};
}


template<class ExecutionPolicy, class ExecutionGroup>
class __grouped_execution_policy
{
  public:
    typedef typename execution_group_traits<ExecutionGroup>::param_type param_type;

    __grouped_execution_policy(const param_type &params)
      : params_(params)
    {}

    const param_type &params() const
    {
      return params_;
    }

  private:
    param_type params_;
};
    

class sequential_execution_policy
{
  public:
    inline sequential_execution_policy(size_t n) : rng{0,n} {}

    template<class ExecutionPolicy>
    __nested_execution_policy<sequential_execution_policy, ExecutionPolicy> operator()(size_t n, ExecutionPolicy &&exec) const
    {
      return __make_nested(operator()(n), exec);
    }

    template<class ExecutionGroup>
    __grouped_execution_policy<sequential_execution_policy,ExecutionGroup> make(size_t n) const
    {
      return __grouped_execution_policy<sequential_execution_policy,ExecutionGroup>{size_t(0),n};
    }

    // XXX should return __grouped_execution_policy
    inline sequential_execution_policy operator()(size_t n) const
    {
      return sequential_execution_policy(n);
    }

    template<class ExecutionGroup, class... Args>
    __grouped_execution_policy<sequential_execution_policy,ExecutionGroup> make(Args&&... args) const
    {
      return __grouped_execution_policy<sequential_execution_policy,ExecutionGroup>{std::forward<Args>(args)...};
    }

//  private:
    __integer_range rng;
};


class parallel_execution_policy
{
  public:
    inline parallel_execution_policy(size_t n) : rng{0,n} {}

    template<class ExecutionPolicy>
    __nested_execution_policy<parallel_execution_policy, ExecutionPolicy> operator()(size_t n, ExecutionPolicy &&exec) const
    {
      return __make_nested(operator()(n), exec);
    }

    inline parallel_execution_policy operator()(size_t n) const
    {
      return parallel_execution_policy(n);
    }

//  private:
    inline parallel_execution_policy(__integer_range rng_) : rng(rng) {}

    __integer_range rng;
};


class concurrent_execution_policy
{
  public:
    inline concurrent_execution_policy(size_t n) : rng{0,n} {}

    template<class ExecutionPolicy>
    __nested_execution_policy<concurrent_execution_policy, ExecutionPolicy> operator()(size_t n, ExecutionPolicy &&exec) const
    {
      return __make_nested(operator()(n), exec);
    }

    inline concurrent_execution_policy operator()(size_t n) const
    {
      return concurrent_execution_policy(n);
    }

    template<class ExecutionGroup>
    __grouped_execution_policy<concurrent_execution_policy,ExecutionGroup> make(size_t n) const
    {
      return __grouped_execution_policy<concurrent_execution_policy,ExecutionGroup>{size_t(0),n};
    }


    template<class ExecutionGroup, class... Args>
    __grouped_execution_policy<concurrent_execution_policy,ExecutionGroup> make(Args&&... args) const
    {
      return __grouped_execution_policy<concurrent_execution_policy,ExecutionGroup>{std::forward<Args>(args)...};
    }

//  private:
    __integer_range rng;
};


//constexpr sequential_execution_policy seq{0};
//constexpr parallel_execution_policy   par{0};
//constexpr concurrent_execution_policy con{0};
const sequential_execution_policy seq{0};
const parallel_execution_policy   par{0};
const concurrent_execution_policy con{0};


template<class ExecutionGroup, class Function, class... Args>
future<void> async(const __grouped_execution_policy<sequential_execution_policy,ExecutionGroup> &exec, Function f, Args&&... args)
{
  // XXX could generalize the launch policy to allow concurrent_execution_policy to make use of this
  return std::async(std::launch::deferred, [=](Args&&... args)
  {
    exception_list exceptions;

    try
    {
      typedef execution_group_traits<ExecutionGroup> traits;

      ExecutionGroup this_group = traits::make(exec.params());

      typedef typename traits::child_type agent_type;
      agent_type& this_agent = this_group.child();

      __scoped_group scope(this_group);

      // execute agents sequentially
      auto rng = traits::range(exec.params());
      for(auto agent_idx = rng.begin();
          agent_idx < rng.end();
          ++agent_idx)
      {
        // move assign the current agent
        this_agent = std::move(agent_type(agent_idx));

        f(this_group, args...);
      }
    } // end try
    catch(...)
    {
      __add_current_exception(exceptions);
      throw exceptions;
    } // end catch
  }, // end lambda
  std::forward<Args>(args)...
  );
}


template<class Function, class... Args>
std::future<void> async(const sequential_execution_policy &exec, Function f, Args&&... args)
{
  __integer_range rng = exec.rng.size() > 0 ? exec.rng : __integer_range{0,1};

  auto params = sequential_group::param_type{rng.begin(),rng.end()};
  typedef __grouped_execution_policy<sequential_execution_policy,sequential_group> policy_type;
  return async(policy_type{params}, f, std::forward<Args>(args)...);
}


template<class ExecutionGroup>
class __subgroup
{
  public:
    typedef execution_group_traits<ExecutionGroup> parent_traits;
    typedef typename parent_traits::param_type     parent_param_type;
    typedef typename parent_traits::size_type      size_type;
    typedef typename parent_traits::child_type     child_type;

    struct param_type
    {
      size_type begin, end;
      parent_param_type parent_params;
    };

    __subgroup(const param_type &params)
      : indices_begin_(params.begin),
        indices_end_(params.end),
        group_(parent_traits::make(params.parent_params))
    {}

    size_type indices_begin() const
    {
      return indices_begin_;
    }

    size_type indices_end() const
    {
      return indices_end_;
    }

    size_type size() const
    {
      return indices_end() - indices_begin();
    }

    ExecutionGroup &group()
    {
      return group_;
    }

    const ExecutionGroup &group() const
    {
      return group_;
    }

    size_type index() const
    {
      return group().index();
    }

    child_type &child()
    {
      return group().child();
    }

  private:
    size_type indices_begin_;
    size_type indices_end_;
    ExecutionGroup group_;
};


template<class ExecutionGroup, class Function, class... Args>
void sync(const __grouped_execution_policy<concurrent_execution_policy,ExecutionGroup> &exec, Function f, Args&&... args)
{
  typedef execution_group_traits<ExecutionGroup> traits;
  
  auto rng = traits::range(exec.params());
  
  std::vector<std::future<void>> futures(rng.end() - rng.begin());
  
  // launch agents
  // XXX could we use the __subgroup idiom here?
  for(auto agent_idx = rng.begin();
      agent_idx < rng.end();
      ++agent_idx)
  {
    // XXX could call std::async(seq) here with a subgroup if async(seq)'s launch policy was generalized
    futures[agent_idx] = std::async(std::launch::async, [=](Args&&... args)
    {
      typedef typename traits::child_type agent_type;
      ExecutionGroup this_group = traits::make(exec.params(), agent_type(agent_idx));
  
      __scoped_group scope(this_group);
  
      f(this_group, args...);
    },
    std::forward<Args>(args)...);
  }
  
  __flatten_and_throw_exceptions(futures.begin(), futures.end());
}


template<class ExecutionGroup, class Function, class... Args>
future<void> async(const __grouped_execution_policy<concurrent_execution_policy,ExecutionGroup> &exec, Function f, Args&&... args)
{
  return std::async(std::launch::async, [=](Args&&... args)
  {
    sync(exec, std::forward<Args>(args)...);
  },
  std::forward<Args>(args)...);
}


template<class Function, class... Args>
void sync(const concurrent_execution_policy &exec, Function f, Args&&... args)
{
  __integer_range rng = exec.rng.size() > 0 ? exec.rng : __integer_range{0,1};
  
  // create a barrier
  std::barrier barrier(rng.end() - rng.begin());
  
  auto group_params = concurrent_group::param_type(rng.begin(),rng.end(),barrier);
  typedef __grouped_execution_policy<concurrent_execution_policy,concurrent_group> policy_type;
  
  policy_type grouped_policy(group_params);
  
  sync(grouped_policy, f, std::forward<Args>(args)...);
}


template<class Function, class... Args>
std::future<void> async(const concurrent_execution_policy &exec, Function f, Args&&... args)
{
  return std::async(std::launch::async, [=](Args&&... args)
  {
    sync(exec, f, std::forward<Args>(args)...);
  },
  std::forward<Args>(args)...);
}


inline unsigned int __log2(unsigned int x)
{
  unsigned int result = 0;
  while(x >>= 1) ++result;
  return result;
}


template<class ExecutionGroup, class Function, class... Args>
future<void> async(const __grouped_execution_policy<parallel_execution_policy,ExecutionGroup> &exec, Function f, Args&&... args)
{
  typedef execution_group_traits<ExecutionGroup> traits;
  typedef typename traits::size_type size_type;

  auto rng = traits::range(exec.params);
  auto group_size = rng.end() - rng.begin();

  const size_t min_num_agents_per_launch = 1000;
  size_t num_concurrent_agents = (group_size + min_num_agents_per_launch - 1) / min_num_agents_per_launch;
  const size_t subscription = std::max(1u, __log2(std::min(1u,std::thread::hardware_concurrency())));

  num_concurrent_agents = std::min<size_t>(subscription * std::thread::hardware_concurrency(), num_concurrent_agents);
  const size_t num_seq_agents_per_concurrent = (group_size + num_concurrent_agents - 1) / num_concurrent_agents;

  return std::async(std::con.make<parallel_group>(num_concurrent_agents), [=](parallel_group &g, Args&&... args)
  {
    auto subgroup_begin = g.child().index() * num_seq_agents_per_concurrent;
    auto subgroup_end   = std::min(group_size, subgroup_begin + num_seq_agents_per_concurrent);

    std::async(std::seq.make<__subgroup<ExecutionGroup>>(subgroup_begin, subgroup_end, exec.params), [=](__subgroup<ExecutionGroup> &subgroup, Args&&... args)
    {
      f(subgroup.group(), args...);
    },
    std::forward<Args>(args)...).wait();
  },
  std::forward<Args>(args)...);
}



template<class Function, class... Args>
std::future<void> async(const parallel_execution_policy &exec, Function f, Args&&... args)
{
//  __integer_range rng = exec.rng.size() > 0 ? exec.rng : __integer_range{0,1};
//
//  auto params = parallel_group::param_type{rng.first,rng.last};
//  typedef __grouped_execution_policy<parallel_execution_policy,parallel_group> policy_type;
//  return std::async(policy_type{params}, f, std::forward<Args>(args)...);

  // XXX implement this in terms of async(__grouped_execution_policy<parallel_execution_policy,parallel_group>)

  __integer_range rng = exec.rng.size() > 0 ? exec.rng : __integer_range{0,1};

  execution_group_traits<parallel_group>::param_type params{rng.begin(),rng.end()};

  const size_t min_num_agents_per_launch = 1000;
  size_t num_launches = (rng.size() + min_num_agents_per_launch - 1) / min_num_agents_per_launch;
  const size_t subscription = std::max(1u, __log2(std::min(1u,std::thread::hardware_concurrency())));

  num_launches = std::min<size_t>(subscription * std::thread::hardware_concurrency(), num_launches);
  const size_t num_agents_per_launch = (rng.size() + num_launches - 1) / num_launches;

  // XXX gcc 4.8 has trouble capturing parameter packs, so forward args through async
  // XXX eliminate this outer async, just join on all the futures
  return std::async(std::launch::async, [=](Args&&... args)
  {
    std::vector<std::future<void>> futures(num_launches);

    // launch asyncs
    // XXX need to collect exceptions
    // XXX could use async(con(seq)) for this, but we'd want to avoid creating a barrier
    //     as well as the expense of manipulating std::this_group
    for(size_t launch_idx = 0; launch_idx < num_launches; ++launch_idx)
    {
      __integer_range launch_rng{launch_idx * num_agents_per_launch, std::min(rng.end(), (launch_idx + 1) * num_agents_per_launch)};

      try
      {
        // XXX gcc 4.8 has trouble capturing parameter packs, so forward args through async
        futures[launch_idx] = std::async(std::launch::async, [=](Args&&... args)
        {
          typedef execution_group_traits<parallel_group> traits;
          typedef typename traits::child_type agent_type;

          // XXX generalize the type of groups created inside async(seq) and use that feature
          //     to implement this loop
          // XXX this_group's size() is wrong when we create it like this
          //     use the __subgroup feature from the prototype header
          parallel_group this_group(rng.begin(), rng.end());
          agent& this_agent = this_group.child();

          __scoped_group scope(this_group);

          for(auto agent_idx = traits::indices_begin(this_group);
              agent_idx < traits::indices_end(this_group);
              ++agent_idx)
          {
            // move assign the current agent
            this_agent = std::move(agent(agent_idx));

            f(this_group, args...);
          }
        },
        std::forward<Args>(args)...
        );
      }
      catch(std::system_error &e)
      {
        std::terminate();
      }
    }

    // join and collect exceptions
    exception_list exceptions;
    for(auto &f : futures)
    {
      try
      {
        f.get();
      }
      catch(...)
      {
        __add_current_exception(exceptions);
      }
    }

    if(exceptions.size() > 0)
    {
      throw exceptions;
    }
  },
  std::forward<Args>(args)...);
}


template<class OuterPolicy, class InnerPolicy, class Function>
struct __async_outer_functor
{
  template<class OuterGroup, class Index>
  struct inner_functor
  {
    OuterGroup &outer_group;
    Function f;
    Index inner_idx;

    template<class InnerGroup, class... Args>
    void operator()(InnerGroup &inner_group, Args&&... args) const
    {
      // create an execution descriptor for f by:
      // * reindexing the inner_group
      // * moving the inner groups and outer groups into a new linked_group

      // XXX are these moves correct?
      // XXX maybe rebind_execution_group should also be able to rebind the index as well?
      InnerGroup reindexed_inner_group(inner_idx, std::move(inner_group));

      // rebind the type of the OuterGroup such that InnerGroup is its child, and link the two
      typename execution_group_traits<OuterGroup>::template rebind_execution_group<InnerGroup> linked_group(std::move(outer_group), std::move(reindexed_inner_group));

      // save old group
      execution_view old_group = std::this_group();

      __set_this_group(linked_group);

      // call f
      f(linked_group, args...);

      // restore old group
      __set_this_group(std::move(old_group));
    }
  };

  __nested_execution_policy<OuterPolicy,InnerPolicy> exec_args;
  Function f;

  template<class OuterGroup, class... Args>
  void operator()(OuterGroup &outer_group, Args&&... args) const
  {
//    // XXX we shouldn't do this n times...
//    // it's the inner_exec's job to create plurality
//    std::vector<std::future<void>> futures(exec_args.inner_exec.n);
//
//    for(size_t i = 0; i < exec_args.inner_exec.n; ++i)
//    {
//      futures[i] = async(exec_args.inner_exec, inner_functor<OuterGroup,size_t>{outer_group, f, i}, args...);
//    }
//
//    // wait for all asyncs
//    for(auto &f : futures)
//    {
//      f.wait();
//    }
    typedef typename execution_group_traits<OuterGroup>::size_type size_type;

    async(exec_args.inner_exec, inner_functor<OuterGroup,size_type>{outer_group, f, outer_group.child().index()}, args...).wait();
  }
};


template<class OuterPolicy, class InnerPolicy, class Function, class... Args>
std::future<void> async(const __nested_execution_policy<OuterPolicy,InnerPolicy> &exec_args, Function f, Args&&... args)
{
  return async(exec_args.outer_exec, __async_outer_functor<OuterPolicy,InnerPolicy,Function>{exec_args,f}, args...);

//  XXX no auto-type for lambda arguments until c++14, and gcc 4.8 has trouble with lambdas + parameter packs
//
//  // invoke an n-sized group to implement the outermost group
//  return async(exec_args.outer_exec(exec_args.n), [&](auto &outer_group)
//  {
//    // XXX this vector would use the allocator in outer_group, if one exists
//    std::vector<std::future<void>> futures(exec_args.inner.n);
//
//    for(size_t i = 0; i < exec_args.inner.n; ++i)
//    {
//      // create an invocation for the inner_group
//      futures[i] = async(exec_args.inner_exec, [&](auto &inner_group)
//      {
//        // create an execution descriptor for f by linking the outer & inner groups
//        // XXX are these moves correct?
//        // XXX should use rebind_execution_group to rebind outer_group<OuterPolicy, inner_group>
//        //     that way, f will receive the type of group it expects
//        execution_group<OuterPolicy,decltype(inner_group)> linked_group(std::move(outer_group), std::move(inner_group));
//
//        // call f
//        f(linked_group, args...);
//      }
//    } // end for
//
//    // wait for all asyncs
//    for(auto &f : futures)
//    {
//      f.wait();
//    }
//  });
}


} // end std

