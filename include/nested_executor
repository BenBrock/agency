#pragma once

#include <execution_categories>
#include <utility>
#include <future>
#include <executor_traits>
#include <__tuple_head>
#include <__tuple_tail>
#include <__tuple_of_references>

namespace std
{


template<class Executor1, class Executor2>
class nested_executor
{
  public:
    using outer_executor_type = Executor1;
    using inner_executor_type = Executor2;

    using execution_category = 
      nested_execution_tag<
        typename executor_traits<outer_executor_type>::execution_category,
        typename executor_traits<inner_executor_type>::execution_category
      >;

    using shape_type = std::pair<
      typename executor_traits<outer_executor_type>::shape_type,
      typename executor_traits<inner_executor_type>::shape_type
    >;

    using index_type = std::pair<
      typename executor_traits<Executor1>::index_type,
      typename executor_traits<Executor2>::index_type
    >;

    nested_executor() = default;

    nested_executor(const outer_executor_type& outer_ex,
                    const inner_executor_type& inner_ex)
      : outer_ex_(outer_ex),
        inner_ex_(inner_ex)
    {}

    template<class Function>
    std::future<void> bulk_async(Function f, shape_type shape)
    {
      using outer_index_type = typename index_type::first_type;
      using inner_index_type = typename index_type::second_type;

      return executor_traits<outer_executor_type>::bulk_async(outer_executor(), [=](outer_index_type outer_idx)
      {
        executor_traits<inner_executor_type>::bulk_invoke(inner_executor(), [=](inner_index_type inner_idx)
        {
          f(index_type(outer_idx, inner_idx));
        },
        shape.second);
      },
      shape.first);
    }

    // XXX assert tuple_size_v<Tuple> == tuple_size_v<shape_type>
    template<class Function, class Tuple>
    std::future<void> bulk_async(Function f, shape_type shape, Tuple shared_arg_tuple)
    {
      using outer_index_type = typename index_type::first_type;
      using inner_index_type = typename index_type::second_type;

      auto shared_head = tuple_head(shared_arg_tuple);
      auto shared_tail = tuple_tail(shared_arg_tuple);

      return executor_traits<outer_executor_type>::bulk_async(outer_executor(), [=](outer_index_type outer_idx, decltype(shared_head)& shared_tuple_head)
      {
        executor_traits<inner_executor_type>::bulk_invoke(inner_executor(), [=,&shared_tuple_head](inner_index_type inner_idx, decltype(shared_tail)& shared_tuple_tail)
        {
          // create a 1-tuple of just a reference to the first shared argument
          auto head_reference  = std::tie(shared_tuple_head);

          // create a tuple of references to the rest of the shared arguments
          auto tail_references = tuple_of_references(shared_tuple_tail);

          // concatenate the reference to the head to the tuple of tail references
          auto full_tuple_of_references = std::tuple_cat(head_reference, tail_references);

          // invoke f
          f(index_type(outer_idx, inner_idx), full_tuple_of_references);
        },
        shape.second,
        shared_tail);
      },
      shape.first,
      shared_head);
    }

    outer_executor_type& outer_executor()
    {
      return outer_ex_;
    }

    const outer_executor_type& outer_executor() const
    {
      return outer_ex_;
    }

    inner_executor_type& inner_executor()
    {
      return inner_ex_;
    }

    const inner_executor_type& inner_executor() const
    {
      return inner_ex_;
    }

  private:
    outer_executor_type outer_ex_;
    inner_executor_type inner_ex_;
};


template<class Executor1, class Executor2, class Function, class... Args>
std::future<void> bulk_async(nested_executor<Executor1,Executor2>& ex,
                             typename nested_executor<Executor1,Executor2>::shape_type shape,
                             Function&& f,
                             Args&&... args)
{
  using executor_type = nested_executor<Executor1,Executor2>;
  auto g = std::bind(std::forward<Function>(f), std::placeholders::_1, std::forward<Args>(args)...);
  return executor_traits<executor_type>::bulk_async(ex, g, shape);
}


template<class Executor1, class Executor2, class Function, class... Args>
void bulk_invoke(nested_executor<Executor1,Executor2>& ex,
                 typename nested_executor<Executor1,Executor2>::shape_type shape,
                 Function&& f,
                 Args&&... args)
{
  using executor_type = nested_executor<Executor1,Executor2>;
  auto g = std::bind(std::forward<Function>(f), std::placeholders::_1, std::forward<Args>(args)...);
  return executor_traits<executor_type>::bulk_invoke(ex, g, shape);
}


}

