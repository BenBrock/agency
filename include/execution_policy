#pragma once

// XXX consider implementing the following inheritance relationship:
// sequential_group -> concurrent_group -> parallel_group -> vector_group
// that way a lambda which expects a parallel_group could always be executable with async(seq)
//
// XXX consider doing away with groups & std::agent
// XXX and just implement the following inheritance:
//     sequential_agent -> concurrent_agent -> parallel_agent -> vector_agent
//     std::agent would be a synonym for one of these
// if i have a sequential_agent i should be able to execute a parallel task
// if i have a concurrent_agent i should be able to execute a parallel task or a vector task
// if i have a parallel_agent i should be able to execute a vector task

#include <future>
#include <utility>
#include <vector>
#include <barrier>
#include <functional>
#include <type_traits>
#include <execution_group>
#include <exception_list>
#include <functional>
#include <asyncable_executor>
#include <memory>

namespace std
{


// XXX add is_execution_policy_v
// XXX maybe this should simply check for the existence of the
//     nested type T::execution_category?
// XXX the problem is that execution groups as well as execution_group_traits
//     also define this typedef
template<class T> struct is_execution_policy : std::false_type {};


template<class T, class Result = void>
struct __enable_if_execution_policy
  : enable_if<is_execution_policy<T>::value,Result>
{};


template<class T, class Result = void>
struct __disable_if_execution_policy
  : enable_if<!is_execution_policy<T>::value,Result>
{};


template<class... Types>
struct __last_type_impl
{
  typedef typename std::tuple_element<sizeof...(Types) - 1, std::tuple<Types...>>::type type;
};


template<>
struct __last_type_impl<>
{
  typedef void type;
};


template<class... Types>
using __last_type = typename __last_type_impl<Types...>::type;


template<class Result, class... Args>
struct __enable_if_nested_call
  : __enable_if_execution_policy<__last_type<Args...>, Result>
{};


template<class Result, class... Args>
struct __disable_if_nested_call
  : __disable_if_execution_policy<__last_type<Args...>, Result>
{};


template<class ExecutionPolicy, class Function, class... Args>
typename __enable_if_execution_policy<decay_t<ExecutionPolicy>>::type
sync(ExecutionPolicy&& exec, Function&& f, Args&&... args);


template<class ExecutionPolicy, class Function, class... Args>
typename __enable_if_execution_policy<decay_t<ExecutionPolicy>,future<void>>::type
async(ExecutionPolicy&& exec, Function&& f, Args&&... args);


// XXX fully flesh this out with the nested typedefs
template<class OuterPolicy, class InnerPolicy>
struct __nested_execution_policy
{
  using execution_category = typename OuterPolicy::execution_category;
  OuterPolicy outer_exec;
  InnerPolicy inner_exec;
};


template<class T1, class T2>
struct is_execution_policy<__nested_execution_policy<T1,T2>>
  : std::integral_constant<
      bool,
      is_execution_policy<T1>::value && is_execution_policy<T2>::value
    >
{};


template<class OuterPolicy, class InnerPolicy>
__nested_execution_policy<OuterPolicy,InnerPolicy> __make_nested(const OuterPolicy outer, const InnerPolicy &inner)
{
  return __nested_execution_policy<OuterPolicy,InnerPolicy>{outer,inner};
}


template<class OuterPolicy, class InnerPolicy, class Function>
struct __async_outer_functor
{
  template<class OuterGroup, class Index>
  struct inner_functor
  {
    OuterGroup &outer_group;
    Function f;
    Index inner_idx;

    template<class InnerGroup, class... Args>
    void operator()(InnerGroup& inner_group, Args&&... args) const
    {
      // reindex the inner group
      execution_group_traits<InnerGroup>::reindex(inner_group, inner_idx);

      // create a new group by rebinding the outer group's child
      auto rebound_group = execution_group_traits<OuterGroup>::rebind_child(std::move(outer_group), std::move(inner_group));

      // call f
      f(rebound_group, args...);
    }
  };

  __nested_execution_policy<OuterPolicy,InnerPolicy> exec_args;
  Function f;

  template<class OuterGroup, class... Args>
  void operator()(OuterGroup& outer_group, Args&&... args) const
  {
    typedef typename execution_group_traits<OuterGroup>::index_type index_type;

    std::async(exec_args.inner_exec, inner_functor<OuterGroup,index_type>{outer_group, f, outer_group.child().index()}, args...).wait();
  }
};


template<class ExecutionCategory, class OuterPolicy, class InnerPolicy, class Function>
std::future<void> __async(ExecutionCategory, const __nested_execution_policy<OuterPolicy,InnerPolicy> &exec_args, Function f)
{
  // XXX use __async_outer_functor because gcc 4.8 has trouble with lambdas + parameter packs
  return std::async(exec_args.outer_exec, __async_outer_functor<OuterPolicy,InnerPolicy,Function>{exec_args,f});
}


// XXX we should assert that ExecutionCategory is stronger than the category of FlatExecutionGroup
// XXX another way to order these parameters would be
// ExecutionCategory, Asyncable, FlatExecutionGroup = __default_execution_group<ExecutionCategory>
template<class FlatExecutionGroup,
         class BulkExecutor,
         class ExecutionCategory = typename execution_group_traits<FlatExecutionGroup>::execution_category>
class __basic_execution_policy
{
  public:
    using execution_group_type = FlatExecutionGroup;
    using execution_category   = ExecutionCategory;
    using group_traits         = std::execution_group_traits<execution_group_type>;
    using group_param_type     = typename group_traits::param_type;
    using agent_param_type     = agent::param_type;

    inline __basic_execution_policy(const __basic_execution_policy& other)
      : params_(other.params_),
        executor_(other.executor_)
    {} 

    inline __basic_execution_policy(const group_param_type& group_params, const BulkExecutor& executor)
      : params_(group_params, agent_param_type()),
        executor_(executor)
    {}

    const std::pair<group_param_type, agent_param_type>& params() const
    {
      return params_;
    }

    // XXX should this function be const?
    // XXX probably should have a const and non-const function member
    BulkExecutor& executor() const
    {
      return executor_;
    }

    template<class... Args>
    __basic_execution_policy regroup(Args&&... args) const
    {
      auto group_params = group_param_type(std::forward<Args>(args)...);
      return __basic_execution_policy(group_params, executor());
    }

    // XXX regroup() should check that OtherExecutionGroup's execution_category is compatible with 
    //     ExecutionCategory (somehow)
    template<class OtherFlatExecutionGroup, class... Args>
    __basic_execution_policy<OtherFlatExecutionGroup,BulkExecutor,execution_category>
      regroup(Args&&... args) const
    {
      using param_type = typename std::execution_group_traits<OtherFlatExecutionGroup>::param_type;
      auto group_params = param_type(std::forward<Args>(args)...); 
      return __basic_execution_policy<OtherFlatExecutionGroup,BulkExecutor,execution_category>(group_params, executor());
    }

    template<class OtherBulkExecutor>
    __basic_execution_policy<FlatExecutionGroup,OtherBulkExecutor,ExecutionCategory> on(const OtherBulkExecutor& executor) const
    {
      return __basic_execution_policy<FlatExecutionGroup,OtherBulkExecutor,ExecutionCategory>(std::get<0>(params()), executor);
    }

  protected:
    std::pair<group_param_type, agent_param_type> params_;
    mutable BulkExecutor executor_;
};


template<class FlatExecutionGroup, class BulkExecutor, class ExecutionCategory>
struct is_execution_policy<__basic_execution_policy<FlatExecutionGroup,BulkExecutor,ExecutionCategory>> : std::true_type {};


template<class ExecutionGroup, class BulkExecutor, class ExecutionCategory, class Function>
void __sync(std::sequential_execution_tag,
            const __basic_execution_policy<ExecutionGroup,BulkExecutor,ExecutionCategory>& exec,
            Function f)
{
  bulk_sync(exec.executor(), 1, [=](size_t)
  {
    using traits = std::execution_group_traits<ExecutionGroup>;
    
    // execute agents sequentially
    auto domain = traits::domain(std::get<0>(exec.params()));
    for(auto agent_idx : domain)
    {
      auto this_group = traits::make_group(exec.params(), std::make_tuple(0, agent_idx));
    
      f(this_group);
    }
  });
}


template<class ExecutionGroup, class BulkExecutor, class ExecutionCategory, class Function>
std::future<void> __async(std::sequential_execution_tag,
                          const __basic_execution_policy<ExecutionGroup,BulkExecutor,ExecutionCategory>& exec,
                          Function f)
{
  return bulk_async(exec.executor(), 1, [=](size_t)
  {
    using traits = std::execution_group_traits<ExecutionGroup>;
    
    // execute agents sequentially
    auto domain = traits::domain(std::get<0>(exec.params()));
    for(auto agent_idx : domain)
    {
      auto this_group = traits::make_group(exec.params(), std::make_tuple(0, agent_idx));
    
      f(this_group);
    }
  });
}


template<class ExecutionGroup, class BulkExecutor, class ExecutionCategory, class Function>
std::future<void> __async2(std::concurrent_execution_tag,
                           const __basic_execution_policy<ExecutionGroup,BulkExecutor,ExecutionCategory>& exec,
                           Function f)
{
  using traits = execution_group_traits<ExecutionGroup>;
  
  auto domain = traits::domain(std::get<0>(exec.params()));
  
  // launch agents
  return bulk_async(exec.executor(), domain.size(), [=](size_t agent_idx)
  {
    auto this_group = traits::make_group(exec.params(), std::make_tuple(0, agent_idx));
  
    f(this_group);
  });
}


template<class ExecutionGroup, class BulkExecutor, class ExecutionCategory, class Function>
std::future<void> __async(std::concurrent_execution_tag,
                          const __basic_execution_policy<ExecutionGroup,BulkExecutor,ExecutionCategory>& exec,
                          Function f)
{
  return __async2(concurrent_execution_tag(), exec, f);
}


template<class ChildGroup, class BulkExecutor, class ExecutionCategory, class Function>
std::future<void> __async(std::concurrent_execution_tag,
                          const __basic_execution_policy<concurrent_group<ChildGroup>,BulkExecutor,ExecutionCategory>& exec,
                          Function f)
{
  auto group_params = std::get<0>(exec.params());

  // XXX shared_ptr might be too expensive for this
  std::shared_ptr<std::barrier> bar = std::make_shared<std::barrier>(group_params.domain().size());

  return __async2(concurrent_execution_tag(), exec, [=](concurrent_group<ChildGroup> &g)
  {
    __set_barrier(g, bar.get());
  
    f(g);
  });
}


template<class BulkExecutor, class ExecutionCategory, class Function>
void __sync(std::concurrent_execution_tag,
            const __basic_execution_policy<concurrent_group<>,BulkExecutor,ExecutionCategory>& exec,
            Function f)
{
  return std::async(exec, f).wait();
}


template<class ExecutionGroup, class BulkExecutor, class ExecutionCategory, class Function>
void __sync(std::parallel_execution_tag,
            const __basic_execution_policy<ExecutionGroup,BulkExecutor,ExecutionCategory>& exec,
            Function f)
{
  return std::async(exec, f).wait();
}


class sequential_execution_policy : public __basic_execution_policy<sequential_group<>, asyncable_executor<std::launch>>
{
  private:
    using super_t = __basic_execution_policy<sequential_group<>, asyncable_executor<std::launch>>;

  public:
    sequential_execution_policy(size_t indices_begin, size_t indices_end)
      : super_t(group_param_type(indices_begin, indices_end), std::launch::deferred)
    {}

    sequential_execution_policy(size_t n) : sequential_execution_policy(0, n) {}

    // this is the nested form of operator()
    template<class OtherExecutionPolicy>
    __nested_execution_policy<sequential_execution_policy, OtherExecutionPolicy>
      operator()(size_t n, const OtherExecutionPolicy &exec) const
    {
      return __make_nested(operator()(n), exec);
    }

    // only enable this operator() if the last parameter in (Arg1, Args...) is not an execution policy
    // this is the flat form of operator()
    template<class Arg1, class... Args>
    typename __disable_if_nested_call<sequential_execution_policy, Arg1, Args...>::type
      operator()(Arg1&& arg1, Args&&... args) const
    {
      return sequential_execution_policy(std::forward<Arg1>(arg1), std::forward<Args>(args)...);
    }
};


template<> struct is_execution_policy<sequential_execution_policy> : std::true_type {};


const sequential_execution_policy seq{1};


class concurrent_execution_policy : public __basic_execution_policy<concurrent_group<>, asyncable_executor<std::launch>>
{
  private:
    using super_t = __basic_execution_policy<concurrent_group<>, asyncable_executor<std::launch>>;

  public:
    concurrent_execution_policy(size_t indices_begin, size_t indices_end)
      : super_t(group_param_type(indices_begin, indices_end), std::launch::async)
    {}

    concurrent_execution_policy(size_t n) : concurrent_execution_policy(0, n) {}

    // this is the nested form of operator()
    template<class OtherExecutionPolicy>
    __nested_execution_policy<concurrent_execution_policy, OtherExecutionPolicy>
      operator()(size_t n, const OtherExecutionPolicy &exec) const
    {
      return __make_nested(operator()(n), exec);
    }

    // only enable this operator() if the last parameter in (Arg1, Args...) is not an execution policy
    // this is the flat form of operator()
    template<class Arg1, class... Args>
    typename __disable_if_nested_call<concurrent_execution_policy, Arg1, Args...>::type
      operator()(Arg1&& arg1, Args&&... args) const
    {
      return concurrent_execution_policy(std::forward<Arg1>(arg1), std::forward<Args>(args)...);
    }
};


template<> struct is_execution_policy<concurrent_execution_policy> : std::true_type {};


const concurrent_execution_policy con{1};


template<class ExecutionGroup>
class __subgroup
{
  public:
    using parent_traits      = execution_group_traits<ExecutionGroup>;
    using execution_category = typename parent_traits::execution_category;
    using parent_param_type  = typename parent_traits::param_type;
    using domain_type        = typename parent_traits::domain_type;
    using index_type         = typename parent_traits::index_type;
    using size_type          = typename parent_traits::size_type;
    using child_type         = typename parent_traits::child_type;

    class param_type
    {
      public:
        param_type(const domain_type& subdomain, const parent_param_type& parent_params)
          : subdomain_(subdomain),
            parent_params_(parent_params)
        {}

        param_type(index_type min, index_type max, const parent_param_type& parent_params)
          : param_type(domain_type{min,max}, parent_params)
        {}

        const domain_type& domain() const
        {
          return subdomain_;
        }

        const parent_param_type &parent_params() const
        {
          return parent_params_;
        }

      private:
        domain_type subdomain_;
        parent_param_type parent_params_;
    };

    template<class ParamTuple, class IndexTuple>
    __subgroup(const domain_type& subdomain, const ParamTuple& parent_params, const IndexTuple& indices)
      : subdomain_(subdomain),
        group_(parent_traits::make_group(parent_params, indices))
    {}

    // tease __subgroup's params out of the ParamTuple's first element
    // and forward everything along to the other constructor
    template<class ParamTuple, class IndexTuple>
    __subgroup(const ParamTuple& params, const IndexTuple& indices)
      : __subgroup(std::get<0>(params).domain(),
                   params,
                   indices)
    {}

    param_type param() const
    {
      return param_type(domain(), group().param());
    }

    const domain_type& domain() const
    {
      return subdomain_;
    }

    size_type size() const
    {
      return subdomain_.size();
    }

    ExecutionGroup &group()
    {
      return group_;
    }

    const ExecutionGroup &group() const
    {
      return group_;
    }

    index_type index() const
    {
      return group().index();
    }

    child_type &child()
    {
      return group().child();
    }

  private:
    domain_type subdomain_;
    ExecutionGroup group_;
};


inline unsigned int __log2(unsigned int x)
{
  unsigned int result = 0;
  while(x >>= 1) ++result;
  return result;
}


template<class ExecutionGroup, class BulkExecutor, class ExecutionCategory, class Function>
future<void> __async(std::parallel_execution_tag,
                     const __basic_execution_policy<ExecutionGroup,BulkExecutor,ExecutionCategory>& exec,
                     Function f)
{
  typedef execution_group_traits<ExecutionGroup> traits;
  typedef typename traits::size_type             size_type;

  auto group_params = std::get<0>(exec.params());

  auto domain = traits::domain(group_params);
  auto group_size = domain.size();

  const size_type min_num_agents_per_launch = 1000;
  size_type num_concurrent_agents = (group_size + min_num_agents_per_launch - 1) / min_num_agents_per_launch;
  const size_type subscription = std::max(1u, __log2(std::min(1u,std::thread::hardware_concurrency())));

  num_concurrent_agents = std::min<size_t>(subscription * std::thread::hardware_concurrency(), num_concurrent_agents);
  const size_type num_seq_agents_per_concurrent = (group_size + num_concurrent_agents - 1) / num_concurrent_agents;

  // XXX we could avoid creating a concurrent_group (and its barrier) here if we wanted to
  // XXX we should just do a bulk_async here instead of relying on std::con
  return std::async(std::con(num_concurrent_agents).on(exec.executor()), [=](concurrent_group<> &g)
  {
    auto subgroup_begin = g.child().index() * num_seq_agents_per_concurrent;
    auto subgroup_end   = std::min(group_size, subgroup_begin + num_seq_agents_per_concurrent);

    std::sync(std::seq.regroup<__subgroup<ExecutionGroup>>(subgroup_begin, subgroup_end, group_params), [=](__subgroup<ExecutionGroup> &subgroup)
    {
      f(subgroup.group());
    });
  });
}


class parallel_execution_policy : public __basic_execution_policy<parallel_group<>, asyncable_executor<std::launch>>
{
  private:
    using super_t = __basic_execution_policy<parallel_group<>, asyncable_executor<std::launch>>;

  public:
    parallel_execution_policy(size_t n)
      : super_t(group_param_type(0, n), std::launch::async)
    {}

    parallel_execution_policy() : parallel_execution_policy(1) {}

    // this is the nested form of operator()
    template<class OtherExecutionPolicy>
    __nested_execution_policy<parallel_execution_policy, OtherExecutionPolicy>
      operator()(size_t n, const OtherExecutionPolicy &exec) const
    {
      return __make_nested(operator()(n), exec);
    }

    // only enable this operator() if the last parameter in (Arg1, Args...) is not an execution policy
    // this is the flat form of operator()
    template<class Arg1, class... Args>
    typename __disable_if_nested_call<parallel_execution_policy, Arg1, Args...>::type
      operator()(Arg1&& arg1, Args&&... args) const
    {
      return parallel_execution_policy(std::forward<Arg1>(arg1), std::forward<Args>(args)...);
    }
};


template<> struct is_execution_policy<parallel_execution_policy> : std::true_type {};


const parallel_execution_policy par;


template<class ExecutionPolicy, class Function, class... Args>
typename __enable_if_execution_policy<decay_t<ExecutionPolicy>>::type
sync(ExecutionPolicy&& exec, Function&& f, Args&&... args)
{
  using execution_category = typename decay_t<ExecutionPolicy>::execution_category;
  return __sync(execution_category(), std::forward<ExecutionPolicy>(exec), std::bind(f, std::placeholders::_1, args...));
}


template<class ExecutionPolicy, class Function, class... Args>
typename __enable_if_execution_policy<decay_t<ExecutionPolicy>,future<void>>::type
async(ExecutionPolicy&& exec, Function&& f, Args&&... args)
{
  using execution_category = typename decay_t<ExecutionPolicy>::execution_category;
  return __async(execution_category(), std::forward<ExecutionPolicy>(exec), std::bind(f, std::placeholders::_1, args...));
}


} // end std

