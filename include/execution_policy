#pragma once

// XXX consider implementing the following inheritance relationship:
// sequential_agent -> concurrent_agent -> parallel_agent -> vector_agent
// that way a lambda which expects a parallel_agent could always be executable with async(seq)
//
// XXX consider doing away with groups & std::agent
// XXX and just implement the following inheritance:
//     sequential_agent -> concurrent_agent -> parallel_agent -> vector_agent
//     std::agent would be a synonym for one of these
// if i have a sequential_agent i should be able to execute a parallel task
// if i have a concurrent_agent i should be able to execute a parallel task or a vector task
// if i have a parallel_agent i should be able to execute a vector task

#include <future>
#include <utility>
#include <barrier>
#include <functional>
#include <type_traits>
#include <execution_group>
#include <functional>
#include <sequential_executor>
#include <concurrent_executor>
#include <parallel_executor>
#include <vector_executor>
#include <memory>

namespace std
{


// XXX add is_execution_policy_v
// XXX maybe this should simply check for the existence of the
//     nested type T::execution_category?
// XXX the problem is that execution agent as well as execution_agent_traits
//     also define this typedef
template<class T> struct is_execution_policy : std::false_type {};


template<class T, class Result = void>
struct __enable_if_execution_policy
  : enable_if<is_execution_policy<T>::value,Result>
{};


template<class T, class Result = void>
struct __disable_if_execution_policy
  : enable_if<!is_execution_policy<T>::value,Result>
{};


template<class... Types>
struct __last_type_impl
{
  typedef typename std::tuple_element<sizeof...(Types) - 1, std::tuple<Types...>>::type type;
};


template<>
struct __last_type_impl<>
{
  typedef void type;
};


template<class... Types>
using __last_type = typename __last_type_impl<Types...>::type;


template<class Result, class... Args>
struct __enable_if_nested_call
  : __enable_if_execution_policy<__last_type<Args...>, Result>
{};


template<class Result, class... Args>
struct __disable_if_nested_call
  : __disable_if_execution_policy<__last_type<Args...>, Result>
{};


template<class ExecutionPolicy, class Function, class... Args>
typename __enable_if_execution_policy<decay_t<ExecutionPolicy>>::type
bulk_invoke(ExecutionPolicy&& exec, Function&& f, Args&&... args);


template<class ExecutionPolicy, class Function, class... Args>
typename __enable_if_execution_policy<decay_t<ExecutionPolicy>,future<void>>::type
bulk_async(ExecutionPolicy&& exec, Function&& f, Args&&... args);


// XXX fully flesh this out with the nested typedefs
template<class OuterPolicy, class InnerPolicy>
struct __nested_execution_policy
{
  // XXX shouldn't the execution_category be nested_execution_tag<outer,inner>?
  using execution_category = typename OuterPolicy::execution_category;
  OuterPolicy outer_exec;
  InnerPolicy inner_exec;
};


template<class T1, class T2>
struct is_execution_policy<__nested_execution_policy<T1,T2>>
  : std::integral_constant<
      bool,
      is_execution_policy<T1>::value && is_execution_policy<T2>::value
    >
{};


template<class OuterPolicy, class InnerPolicy>
__nested_execution_policy<OuterPolicy,InnerPolicy> __make_nested(const OuterPolicy outer, const InnerPolicy &inner)
{
  return __nested_execution_policy<OuterPolicy,InnerPolicy>{outer,inner};
}


template<class OuterPolicy, class InnerPolicy, class Function>
struct __bulk_async_outer_functor
{
  template<class OuterAgent, class Index>
  struct inner_functor
  {
    OuterAgent &outer_agent;
    Function f;
    Index inner_idx;

    template<class InnerAgent, class... Args>
    void operator()(InnerAgent& inner_agent, Args&&... args) const
    {
      // reindex the inner agent
      execution_agent_traits<InnerAgent>::reindex(inner_agent, inner_idx);

      // create a new agent by rebinding the outer agent's child
      auto rebound_agent = execution_agent_traits<OuterAgent>::rebind_child(std::move(outer_agent), std::move(inner_agent));

      // call f
      f(rebound_agent, args...);
    }
  };

  __nested_execution_policy<OuterPolicy,InnerPolicy> exec_args;
  Function f;

  template<class OuterAgent, class... Args>
  void operator()(OuterAgent& outer_agent, Args&&... args) const
  {
    typedef typename execution_agent_traits<OuterAgent>::index_type index_type;

    std::bulk_async(exec_args.inner_exec, inner_functor<OuterAgent,index_type>{outer_agent, f, outer_agent.child().index()}, args...).wait();
  }
};


template<class ExecutionCategory, class OuterPolicy, class InnerPolicy, class Function>
std::future<void> __bulk_async(ExecutionCategory, const __nested_execution_policy<OuterPolicy,InnerPolicy> &exec_args, Function f)
{
  // XXX use __async_outer_functor because gcc 4.8 has trouble with lambdas + parameter packs
  return std::bulk_async(exec_args.outer_exec, __bulk_async_outer_functor<OuterPolicy,InnerPolicy,Function>{exec_args,f});
}


// XXX we should assert that ExecutionCategory is stronger than the category of FlatExecutionAgent
// XXX another way to order these parameters would be
// ExecutionCategory, Asyncable, FlatExecutionGroup = __default_execution_group<ExecutionCategory>
template<class FlatExecutionAgent,
         class BulkExecutor,
         class ExecutionCategory = typename execution_agent_traits<FlatExecutionAgent>::execution_category>
class __basic_execution_policy
{
  public:
    using execution_agent_type = FlatExecutionAgent;
    using executor_type        = BulkExecutor;
    using execution_category   = ExecutionCategory;

  private:
    using agent_traits         = std::execution_agent_traits<execution_agent_type>;
    using agent_param_type     = agent::param_type;

  public:
    using param_tuple_type     = typename agent_traits::param_tuple_type;

    inline __basic_execution_policy(const __basic_execution_policy& other)
      : param_tuple_(other.param_tuple_),
        executor_(other.executor_)
    {} 

    inline __basic_execution_policy(const param_tuple_type& param_tuple, const executor_type& executor = executor_type())
      : param_tuple_(param_tuple),
        executor_(executor)
    {}

    inline __basic_execution_policy(const typename agent_traits::param_type& agent_params, const executor_type& executor = executor_type())
      : __basic_execution_policy(param_tuple_type(agent_params, agent_param_type()), executor)
    {}

    const param_tuple_type& param_tuple() const
    {
      return param_tuple_;
    }

    executor_type& executor() const
    {
      return executor_;
    }

    template<class... Args>
    __basic_execution_policy reagent(Args&&... args) const
    {
      auto agent_params = agent_param_type(std::forward<Args>(args)...);
      return __basic_execution_policy(agent_params, executor());
    }

    // XXX reagent() should check that OtherExecutionAgent's execution_category is compatible with 
    //     ExecutionCategory (somehow)
    template<class OtherFlatExecutionAgent, class... Args>
    __basic_execution_policy<OtherFlatExecutionAgent,executor_type,execution_category>
      reagent(Args&&... args) const
    {
      using param_type = typename std::execution_agent_traits<OtherFlatExecutionAgent>::param_type;
      auto agent_params = param_type(std::forward<Args>(args)...); 
      return __basic_execution_policy<OtherFlatExecutionAgent,executor_type,execution_category>(agent_params, executor());
    }

    template<class OtherBulkExecutor>
    __basic_execution_policy<FlatExecutionAgent,OtherBulkExecutor,ExecutionCategory> on(const OtherBulkExecutor& executor) const
    {
      return __basic_execution_policy<FlatExecutionAgent,OtherBulkExecutor,ExecutionCategory>(std::get<0>(param_tuple()), executor);
    }

  protected:
    param_tuple_type param_tuple_;

    // executor_ needs to be mutable, because:
    // * the global execution policy objects are constexpr
    // * executor.bulk_add() is a non-const member function
    mutable executor_type executor_;
};


template<class FlatExecutionAgent, class BulkExecutor, class ExecutionCategory>
struct is_execution_policy<__basic_execution_policy<FlatExecutionAgent,BulkExecutor,ExecutionCategory>> : std::true_type {};


// ExecutionCategory1 corresponds to the category of the executor
// XXX ExecutionCategory2 corresponds to the category of the policy
// XXX this overload should only be selected if ExecutionCategory1 is stronger than ExecutionCategory2
template<class ExecutionCategory1, class ExecutionAgent, class BulkExecutor, class ExecutionCategory2, class Function>
void __bulk_invoke(ExecutionCategory1,
                   const __basic_execution_policy<ExecutionAgent,BulkExecutor,ExecutionCategory2>& exec,
                   Function f)
{
  using traits = std::execution_agent_traits<ExecutionAgent>;
  auto param_tuple = exec.param_tuple();
  auto domain = traits::domain(std::get<0>(param_tuple));

  bulk_invoke(exec.executor(), domain.size(), [=](size_t agent_idx)
  {
    auto this_agent = traits::make_agent(param_tuple, std::make_tuple(0, domain[agent_idx]));
    
    f(this_agent);
  });
}


// ExecutionCategory1 corresponds to the category of the executor
// XXX ExecutionCategory2 corresponds to the category of the policy
// XXX this overload should only be selected if ExecutionCategory1 is stronger than ExecutionCategory2
template<class ExecutionCategory1, class ExecutionAgent, class BulkExecutor, class ExecutionCategory2, class Function>
std::future<void> __bulk_async(ExecutionCategory1,
                               const __basic_execution_policy<ExecutionAgent,BulkExecutor,ExecutionCategory2>& exec,
                               Function f)
{
  using traits = std::execution_agent_traits<ExecutionAgent>;
  auto param_tuple = exec.param_tuple();
  auto domain = traits::domain(std::get<0>(param_tuple));

  return bulk_async(exec.executor(), domain.size(), [=](size_t agent_idx)
  {
    auto this_agent = traits::make_agent(param_tuple, std::make_tuple(0, domain[agent_idx]));
    
    f(this_agent);
  });
}


template<class ChildAgent, class BulkExecutor, class Function>
std::future<void> __bulk_async(std::concurrent_execution_tag,
                               const __basic_execution_policy<concurrent_agent<ChildAgent>,BulkExecutor,std::concurrent_execution_tag>& exec,
                               Function f)
{
  auto agent_params = std::get<0>(exec.param_tuple());

  // XXX shared_ptr might be too expensive for this
  std::shared_ptr<std::barrier> bar = std::make_shared<std::barrier>(agent_params.domain().size());

  // pass 0 as the category to ensure we get the fully-generic form of __async() above
  return __bulk_async(0, exec, [=](concurrent_agent<ChildAgent> &g)
  {
    __set_barrier(g, bar.get());
  
    f(g);
  });
}


template<class ChildAgent, class BulkExecutor, class Function>
void __bulk_invoke(std::concurrent_execution_tag,
                   const __basic_execution_policy<concurrent_agent<ChildAgent>,BulkExecutor,std::concurrent_execution_tag>& exec,
                   Function f)
{
  // call std::bulk_async(...).wait() so we're sure that we get our barrier constructed
  // by the function above
  return std::bulk_async(exec, f).wait();
}


class sequential_execution_policy : public __basic_execution_policy<sequential_agent<>, sequential_executor>
{
  private:
    using super_t = __basic_execution_policy<sequential_agent<>, sequential_executor>;

  public:
    using typename super_t::execution_agent_type;

    sequential_execution_policy(const execution_agent_type::param_type& param)
      : super_t(execution_agent_traits<execution_agent_type>::param_tuple_type(param, std::agent::param_type()))
    {}

    sequential_execution_policy(size_t indices_begin, size_t indices_end)
      : sequential_execution_policy(execution_agent_type::param_type(indices_begin, indices_end))
    {}

    sequential_execution_policy(size_t n) : sequential_execution_policy(0, n) {}

    // this is the nested form of operator()
    template<class OtherExecutionPolicy>
    __nested_execution_policy<sequential_execution_policy, OtherExecutionPolicy>
      operator()(size_t n, const OtherExecutionPolicy &exec) const
    {
      return __make_nested(operator()(n), exec);
    }

    // only enable this operator() if the last parameter in (Arg1, Args...) is not an execution policy
    // this is the flat form of operator()
    template<class Arg1, class... Args>
    typename __disable_if_nested_call<sequential_execution_policy, Arg1, Args...>::type
      operator()(Arg1&& arg1, Args&&... args) const
    {
      return sequential_execution_policy(std::forward<Arg1>(arg1), std::forward<Args>(args)...);
    }
};


template<> struct is_execution_policy<sequential_execution_policy> : std::true_type {};


const sequential_execution_policy seq{1};


class concurrent_execution_policy : public __basic_execution_policy<concurrent_agent<>, concurrent_executor>
{
  private:
    using super_t = __basic_execution_policy<concurrent_agent<>, concurrent_executor>;

  public:
    using typename super_t::execution_agent_type;

    concurrent_execution_policy(const execution_agent_type::param_type& param)
      : super_t(execution_agent_traits<execution_agent_type>::param_tuple_type(param, std::agent::param_type()))
    {}

    concurrent_execution_policy(size_t indices_begin, size_t indices_end)
      : concurrent_execution_policy(execution_agent_type::param_type(indices_begin, indices_end))
    {}

    concurrent_execution_policy(size_t n) : concurrent_execution_policy(0, n) {}

    // this is the nested form of operator()
    template<class OtherExecutionPolicy>
    __nested_execution_policy<concurrent_execution_policy, OtherExecutionPolicy>
      operator()(size_t n, const OtherExecutionPolicy &exec) const
    {
      return __make_nested(operator()(n), exec);
    }

    // only enable this operator() if the last parameter in (Arg1, Args...) is not an execution policy
    // this is the flat form of operator()
    template<class Arg1, class... Args>
    typename __disable_if_nested_call<concurrent_execution_policy, Arg1, Args...>::type
      operator()(Arg1&& arg1, Args&&... args) const
    {
      return concurrent_execution_policy(std::forward<Arg1>(arg1), std::forward<Args>(args)...);
    }
};


template<> struct is_execution_policy<concurrent_execution_policy> : std::true_type {};


const concurrent_execution_policy con{1};


class parallel_execution_policy : public __basic_execution_policy<parallel_agent<>, parallel_executor>
{
  private:
    using super_t = __basic_execution_policy<parallel_agent<>, parallel_executor>;

  public:
    using typename super_t::execution_agent_type;

    parallel_execution_policy(const execution_agent_type::param_type& param)
      : super_t(execution_agent_traits<execution_agent_type>::param_tuple_type(param, std::agent::param_type()))
    {}

    parallel_execution_policy(size_t indices_begin, size_t indices_end)
      : parallel_execution_policy(execution_agent_type::param_type(indices_begin, indices_end))
    {}

    parallel_execution_policy(size_t n) : parallel_execution_policy(0, n) {}

    parallel_execution_policy() : parallel_execution_policy(1) {}

    // this is the nested form of operator()
    template<class OtherExecutionPolicy>
    __nested_execution_policy<parallel_execution_policy, OtherExecutionPolicy>
      operator()(size_t n, const OtherExecutionPolicy &exec) const
    {
      return __make_nested(operator()(n), exec);
    }

    // only enable this operator() if the last parameter in (Arg1, Args...) is not an execution policy
    // this is the flat form of operator()
    template<class Arg1, class... Args>
    typename __disable_if_nested_call<parallel_execution_policy, Arg1, Args...>::type
      operator()(Arg1&& arg1, Args&&... args) const
    {
      return parallel_execution_policy(std::forward<Arg1>(arg1), std::forward<Args>(args)...);
    }
};


template<> struct is_execution_policy<parallel_execution_policy> : std::true_type {};


const parallel_execution_policy par;


class vector_execution_policy : public __basic_execution_policy<vector_agent<>, vector_executor>
{
  private:
    using super_t = __basic_execution_policy<vector_agent<>, vector_executor>;

  public:
    using typename super_t::execution_agent_type;

    vector_execution_policy(const execution_agent_type::param_type& param)
      : super_t(execution_agent_traits<execution_agent_type>::param_tuple_type(param, std::agent::param_type()))
    {}

    vector_execution_policy(size_t indices_begin, size_t indices_end)
      : vector_execution_policy(execution_agent_type::param_type(indices_begin, indices_end))
    {}

    vector_execution_policy(size_t n) : vector_execution_policy(0, n) {}

    vector_execution_policy() : vector_execution_policy(1) {}

    // this is the nested form of operator()
    template<class OtherExecutionPolicy>
    __nested_execution_policy<vector_execution_policy, OtherExecutionPolicy>
      operator()(size_t n, const OtherExecutionPolicy &exec) const
    {
      return __make_nested(operator()(n), exec);
    }

    // only enable this operator() if the last parameter in (Arg1, Args...) is not an execution policy
    // this is the flat form of operator()
    template<class Arg1, class... Args>
    typename __disable_if_nested_call<vector_execution_policy, Arg1, Args...>::type
      operator()(Arg1&& arg1, Args&&... args) const
    {
      return vector_execution_policy(std::forward<Arg1>(arg1), std::forward<Args>(args)...);
    }
};


template<> struct is_execution_policy<vector_execution_policy> : std::true_type {};


const vector_execution_policy vec;


template<class ExecutionPolicy, class Function, class... Args>
typename __enable_if_execution_policy<decay_t<ExecutionPolicy>>::type
bulk_invoke(ExecutionPolicy&& exec, Function&& f, Args&&... args)
{
  // XXX the execution_category we dispatch on should be the category of the policy's executor
  using execution_category = typename decay_t<ExecutionPolicy>::execution_category;
  return __bulk_invoke(execution_category(), exec, std::bind(f, std::placeholders::_1, args...));
}


template<class ExecutionPolicy, class Function, class... Args>
typename __enable_if_execution_policy<decay_t<ExecutionPolicy>,future<void>>::type
bulk_async(ExecutionPolicy&& exec, Function&& f, Args&&... args)
{
  // XXX the execution_category we dispatch on should be the category of the policy's executor
  using execution_category = typename decay_t<ExecutionPolicy>::execution_category;
  return __bulk_async(execution_category(), exec, std::bind(f, std::placeholders::_1, args...));
}


} // end std

