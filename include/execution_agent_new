#pragma once

#include <execution_agent>
#include <type_traits>
#include <__type_traits>
#include <__tuple_head>
#include <__tuple_tail>
#include <__shape>
#include <__unwrap_tuple_if_not_nested>

namespace std
{


__DEFINE_HAS_NESTED_TYPE(__has_param_type, param_type);
__DEFINE_HAS_NESTED_TYPE(__has_inner_execution_agent_type, inner_execution_agent_type);


template<class ExecutionAgent, class Enable = void>
struct __execution_agent_traits_new_base
{
};


template<class ExecutionAgent>
struct __execution_agent_traits_new_base<
  ExecutionAgent,
  typename std::enable_if<
    __has_inner_execution_agent_type<ExecutionAgent>::type
  >::type
>
{
  using inner_execution_agent_type = typename ExecutionAgent::inner_execution_agent_type;
};


template<class ExecutionAgent>
struct execution_agent_traits_new : __execution_agent_traits_new_base<ExecutionAgent>
{
  using execution_agent_type = ExecutionAgent;
  using execution_category = typename execution_agent_type::execution_category;
  using index_type = decay_t<
    decltype(
      std::declval<execution_agent_type>().index()
    )
  >;

  using size_type = decay_t<
    decltype(
      std::declval<execution_agent_type>().group_size()
    )
  >;

  private:
    template<class T>
    struct execution_agent_param
    {
      using type = typename T::param_type;
    };

  public:

  using param_type = typename __lazy_conditional<
    __has_param_type<execution_agent_type>::value,
    execution_agent_param<execution_agent_type>,
    __identity<size_type>
  >::type;

  // XXX should default to regular_grid<index_type> if no .domain() is found
  // XXX should add function domain(const execution_agent_type& agent)
  //     if agent.domain() is not found, return regular_grid<index_type>(shape(agent))
  using domain_type = decay_t<
    decltype(
      std::declval<execution_agent_type>().domain()
    )
  >;

  using shape_type = decltype(__shape<execution_agent_type>(std::declval<param_type>()));

  static shape_type shape(const param_type& param)
  {
    return __shape<ExecutionAgent>(param);
  }

  template<class Tuple, class Function>
  static typename enable_if<
    (__tuple_size_if_tuple_else_zero<shape_type>::value == __tuple_size_if_tuple_else_zero<Tuple>::value)
  >::type
    execute(const Tuple& indices, const param_type& param, Function f)
  {
    ExecutionAgent::execute(indices, param, f);
  }

  private:
    template<class ExecutionAgent1>
    struct test_for_make_shared_initializer
    {
      template<
        class ExecutionAgent2,
        typename = decltype(
          ExecutionAgent2::make_shared_initializer(
            std::declval<param_type>()
          )
        )
      >
      static true_type test(int);

      template<class>
      static false_type test(...);

      using type = decltype(test<ExecutionAgent1>(0));
    };

    using has_make_shared_initializer = typename test_for_make_shared_initializer<execution_agent_type>::type;

    // XXX this should only be enabled for flat execution_agents
    //     nested agents should return a tuple of shared initializers
    template<class ExecutionAgent1>
    static decltype(std::ignore) make_shared_initializer(const param_type&, std::false_type)
    {
      return std::ignore;
    }

    template<class ExecutionAgent1>
    static auto make_shared_initializer(const param_type& param, std::true_type)
      -> decltype(
           ExecutionAgent1::make_shared_initializer(param)
         )
    {
      return ExecutionAgent1::make_shared_initializer(param);
    }

  public:

  static auto make_shared_initializer(const param_type& param)
    -> decltype(
         make_shared_initializer<execution_agent_type>(param, has_make_shared_initializer())
       )
  {
    return make_shared_initializer<execution_agent_type>(param, has_make_shared_initializer());
  }

  using shared_initializer_type = decltype(
    make_shared_initializer(std::declval<param_type>())
  );


  private:
    template<class Tuple1, class Function, class Tuple2>
    static typename enable_if<
      (__tuple_size_if_tuple_else_zero<shape_type>::value == __tuple_size_if_tuple_else_zero<Tuple1>::value) &&
      (__tuple_size_if_tuple_else_zero<shape_type>::value == __tuple_size_if_tuple_else_zero<Tuple2>::value)
    >::type
      execute(const Tuple1& indices, const param_type& param, Function f, Tuple2&, std::false_type)
    {
      ExecutionAgent::execute(indices, param, f);
    }

    template<class Tuple1, class Function, class Tuple2>
    static typename enable_if<
      (__tuple_size_if_tuple_else_zero<shape_type>::value == __tuple_size_if_tuple_else_zero<Tuple1>::value) &&
      (__tuple_size_if_tuple_else_zero<shape_type>::value == __tuple_size_if_tuple_else_zero<Tuple2>::value)
    >::type
      execute(const Tuple1& indices, const param_type& param, Function f, Tuple2& shared_params, std::true_type)
    {
      ExecutionAgent::execute(indices, param, f, shared_params);
    }


  public:

  template<class Tuple1, class Function, class Tuple2>
  static typename enable_if<
    (__tuple_size_if_tuple_else_zero<shape_type>::value == __tuple_size_if_tuple_else_zero<Tuple1>::value) &&
    (__tuple_size_if_tuple_else_zero<shape_type>::value == __tuple_size_if_tuple_else_zero<Tuple2>::value)
  >::type
    execute(const Tuple1& indices, const param_type& param, Function f, Tuple2& shared_params)
  {
    execute(indices, param, f, shared_params, has_make_shared_initializer());
  }
};


template<class ExecutionCategory>
class __basic_execution_agent_new
{
  public:
    using execution_category = ExecutionCategory;

    size_t index() const
    {
      return index_;
    }

    const regular_grid<size_t>& domain() const
    {
      return domain_;
    }

    // XXX should provide group_shape(), not group_size()
    //     group_size() is derivable from group_shape
    //     group_shape() is only derivable from group_size()
    //     for 1D domains
    size_t group_size() const
    {
      return domain_.size();
    }

    class param_type
    {
      public:
        param_type(const param_type& other)
          : domain_(other.domain_)
        {}

        param_type(const regular_grid<size_t>& d)
          : domain_(d)
        {}

        param_type(size_t min, size_t max)
          : param_type(regular_grid<size_t>(min,max))
        {}

        const regular_grid<size_t>& domain() const
        {
          return domain_;
        }

      private:
        regular_grid<size_t> domain_;
    };

    // XXX merge this into the constructor?
    template<class Index, class Function>
    static void execute(const Index& index, const param_type& param, Function f)
    {
      auto self = __basic_execution_agent_new(index, param);
      f(self);
    }

  protected:
    template<class Index>
    __basic_execution_agent_new(const Index& index, const param_type& param)
      : index_(index),
        domain_(param.domain())
    {}

  private:
    size_t index_;
    regular_grid<size_t> domain_;
};


using sequential_agent_new = __basic_execution_agent_new<sequential_execution_tag>;


class concurrent_agent_new : public __basic_execution_agent_new<concurrent_execution_tag>
{
  private:
    using super_t = __basic_execution_agent_new<concurrent_execution_tag>;

  public:
    void wait() const
    {
      barrier_.count_down_and_wait();
    }

    struct shared_param_type
    {
      shared_param_type(const typename super_t::param_type& param)
        : count_(param.domain().size()),
          barrier_(count_)
      {}

      shared_param_type(const shared_param_type& other)
        : count_(other.count_),
          barrier_(count_)
      {}

      int count_;
      std::barrier barrier_;
    };

    static shared_param_type make_shared_initializer(const param_type& param)
    {
      return shared_param_type(param);
    }

    template<class Index, class Function>
    static void execute(const Index& index, const param_type& param, Function f, shared_param_type& shared_param)
    {
      auto self = concurrent_agent_new(index, param, shared_param);

      f(self);
    }

  private:
    std::barrier &barrier_;

  protected:
    template<class Index>
    concurrent_agent_new(const Index& index, const param_type& param, shared_param_type& shared_param)
      : super_t(index, param),
        barrier_(shared_param.barrier_)
    {}
};



template<class OuterExecutionAgent, class InnerExecutionAgent>
class __execution_group_new : public OuterExecutionAgent
{
  private:
    template<class> friend struct execution_agent_traits_new; 

    using outer_traits = execution_agent_traits_new<OuterExecutionAgent>;
    using inner_traits = execution_agent_traits_new<InnerExecutionAgent>;

    using outer_execution_category = typename outer_traits::execution_category;
    using inner_execution_category = typename inner_traits::execution_category;

  public:
    using execution_category = nested_execution_tag<
      outer_execution_category,
      inner_execution_category
    >;

    // XXX should get rid of this typedef
    using outer_execution_agent_type = OuterExecutionAgent;

    using inner_execution_agent_type = InnerExecutionAgent;

    inner_execution_agent_type& child()
    {
      return inner_agent_;
    }

    const inner_execution_agent_type& inner() const
    {
      return inner_agent_;
    }

    using param_type = std::tuple<
      typename outer_traits::param_type,
      typename inner_traits::param_type
    >;

    template<class Tuple, class Function>
    static void execute(const Tuple& indices, const param_type& param, Function f)
    {
      outer_traits::execute(tuple_head(indices), std::get<0>(param), [=,&indices](outer_execution_agent_type& outer_agent)
      {
        auto tail_indices = tuple_tail(indices);

        // if the inner agent isn't nested, we need to unwrap the tail tuple
        auto& inner_indices = __unwrap_tuple_if_not_nested<inner_execution_category>(tail_indices);

        inner_traits::execute(inner_indices, std::get<1>(param), [=,&outer_agent](inner_execution_agent_type& inner_agent)
        {
          auto self = __execution_group_new(std::move(outer_agent), inner_agent);

          f(self);
        });
      });
    }


    template<class Tuple1, class Function, class Tuple2>
    static void execute(const Tuple1& indices, const param_type& param, Function f, Tuple2& shared_param)
    {
      outer_traits::execute(tuple_head(indices), std::get<0>(param), [=,&indices,&shared_param](outer_execution_agent_type& outer_agent)
      {
        auto tail_indices = tuple_tail(indices);

        // if the inner agent isn't nested, we need to unwrap the tail index tuple
        auto& inner_indices = __unwrap_tuple_if_not_nested<inner_execution_category>(tail_indices);

        auto shared_param_tail = tuple_tail(shared_param);

        // if the inner agent isn't nested, we need to unwrap the tail shared param
        auto& inner_shared_param = __unwrap_tuple_if_not_nested<inner_execution_category>(shared_param_tail);

        inner_traits::execute(inner_indices, std::get<1>(param), [=,&outer_agent](inner_execution_agent_type& inner_agent)
        {
          auto self = __execution_group_new(std::move(outer_agent), inner_agent);

          f(self);
        },
        inner_shared_param);
      },
      tuple_head(shared_param)
      );
    }


    static auto make_shared_initializer(const param_type& param)
      -> decltype(
           std::tuple_cat(
             __make_tuple_if_not_nested<outer_execution_category>(
               outer_traits::make_shared_initializer(std::get<0>(param))
             ),
             __make_tuple_if_not_nested<inner_execution_category>(
               inner_traits::make_shared_initializer(std::get<1>(param))
             )
           )
         )
    {
      auto outer_shared_init = outer_traits::make_shared_initializer(std::get<0>(param));
      auto inner_shared_init = inner_traits::make_shared_initializer(std::get<1>(param));

      auto outer_tuple = __make_tuple_if_not_nested<outer_execution_category>(outer_shared_init);
      auto inner_tuple = __make_tuple_if_not_nested<inner_execution_category>(inner_shared_init);

      return std::tuple_cat(outer_tuple, inner_tuple);
    }


  protected:
    inner_execution_agent_type inner_agent_;

    __execution_group_new(outer_execution_agent_type&& outer_agent, inner_execution_agent_type& inner_agent)
      : outer_execution_agent_type(std::move(outer_agent)),
        inner_agent_(inner_agent)
    {}
};


template<class InnerExecutionAgent>
using sequential_group_new = __execution_group_new<sequential_agent_new, InnerExecutionAgent>;

template<class InnerExecutionAgent>
using concurrent_group_new = __execution_group_new<concurrent_agent_new, InnerExecutionAgent>;


}

