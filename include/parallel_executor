#pragma once

#include <concurrent_executor>
#include <sequential_executor>

namespace std
{


// XXX maybe we could parameterize this as an executor adaptor
class parallel_executor
{
  public:
    using execution_category = std::parallel_execution_tag;

    using index_type = size_t;

    parallel_executor()
      : min_num_agents_per_launch_(1000),
        subscription_(std::max(1u, log2(std::min(1u,std::thread::hardware_concurrency())))),
        con_exec_(),
        seq_exec_()
    {}

    template<class Function>
    void bulk_add(size_t n, Function f)
    {
      auto partitioning = partition(n);

      con().bulk_add(partitioning.first, [=](size_t outer_idx)
      {
        auto subgroup_begin = outer_idx * partitioning.second;
        auto subgroup_end   = std::min(n, subgroup_begin + partitioning.second);

        bulk_sync(seq(), subgroup_end - subgroup_begin, [=](size_t inner_idx)
        {
          auto index = subgroup_begin + inner_idx;

          f(index);
        });
      });
    }

    // returns (number of concurrent agents, number of sequential agents)
    std::pair<size_t,size_t> partition(size_t n) const
    {
      size_t num_concurrent_agents = (n + min_num_agents_per_launch_ - 1) / min_num_agents_per_launch_;
      num_concurrent_agents = std::min<size_t>(subscription_ * std::thread::hardware_concurrency(), num_concurrent_agents);

      const size_t num_seq_agents_per_concurrent = (n + num_concurrent_agents - 1) / num_concurrent_agents;

      return std::make_pair(num_concurrent_agents, num_seq_agents_per_concurrent);
    }

    inline concurrent_executor& con()
    {
      return con_exec_;
    }

    inline const concurrent_executor& con() const
    {
      return con_exec_;
    }

    inline sequential_executor& seq()
    {
      return seq_exec_;
    }

    inline const sequential_executor& seq() const
    {
      return seq_exec_;
    }

  private:
    inline unsigned int log2(unsigned int x)
    {
      unsigned int result = 0;
      while(x >>= 1) ++result;
      return result;
    }

    size_t min_num_agents_per_launch_;
    size_t subscription_;
    concurrent_executor con_exec_;
    sequential_executor seq_exec_;
};


template<class Function, class... Args>
std::future<void> bulk_async(parallel_executor& ex, size_t n, Function&& f, Args&&... args)
{
  auto g = std::bind(std::forward<Function>(f), std::placeholders::_1, std::function<Args>(args)...);

  auto partitioning = ex.partition(n);

  return bulk_async(ex.con(), partitioning.first, [=,&ex](size_t outer_idx)
  {
    auto subgroup_begin = outer_idx * partitioning.second;
    auto subgroup_end   = std::min(n, subgroup_begin + partitioning.second);

    bulk_sync(ex.seq(), subgroup_end - subgroup_begin, [=](size_t inner_idx)
    {
      auto index = subgroup_begin + inner_idx;

      g(index);
    });
  });
}


template<class Function, class... Args>
void bulk_sync(parallel_executor& ex, size_t n, Function&& f, Args&&... args)
{
  std::bulk_async(ex, n, std::forward<Function>(f), std::forward<Args>(args)...).wait();
}


}

