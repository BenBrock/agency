#pragma once

#include_next <future>
#include <type_traits>
#include <exception_list>

namespace std
{


template<class Function, class... Args>
typename std::result_of<Function(Args...)>::type
  sync(std::launch, Function&& f, Args&&... args)
{
  return std::forward<Function>(f)(std::forward<Args>(args)...);
}


template<class T>
future<decay_t<T>> make_ready_future(T&& value)
{
  promise<decay_t<T>> p;
  p.set_value(std::forward<T>(value));
  return p.get_future();
}


inline future<void> make_ready_future()
{
  promise<void> p;
  p.set_value();
  return p.get_future();
}


// XXX when_all is supposed to return a future<vector>
template<typename ForwardIterator>
future<void> when_all(ForwardIterator first, ForwardIterator last)
{
  exception_list exceptions = __flatten_into_exception_list(first, last);

  promise<void> p;

  if(exceptions.size() > 0)
  {
    p.set_exception(make_exception_ptr(exceptions));
  }
  else
  {
    p.set_value();
  }

  return p.get_future();
}


}

