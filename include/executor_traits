#pragma once

#include <__type_traits>


namespace std
{


__DEFINE_HAS_NESTED_TYPE(__has_index_type, index_type);
__DEFINE_HAS_NESTED_TYPE(__has_shape_type, shape_type);


template<class Executor>
struct executor_traits
{
  private:
    template<class T>
    struct executor_index
    {
      using type = typename T::index_type;
    };

    template<class T>
    struct executor_shape
    {
      using type = typename T::shape_type;
    };

  public:
    using executor_type = Executor;

    using execution_category = typename Executor::execution_category;

    using index_type = typename __lazy_conditional<
      __has_index_type<executor_type>::value,
      executor_index<executor_type>,
      __identity<size_t>
    >::type;

    using shape_type = typename __lazy_conditional<
      __has_shape_type<executor_type>::value,
      executor_shape<executor_type>,
      __identity<index_type>
    >::type;

    template<class Function>
    static void bulk_add(executor_type& ex, shape_type shape, Function f)
    {
      return ex.bulk_add(shape, f);
    }


    // XXX new stuff

    template<class Function, class T>
    static std::future<void> bulk_async(executor_type& ex, Function f, shape_type shape, T shared_arg)
    {
      return ex.bulk_async(f, shape, shared_arg);
    }

    template<class Function>
    static std::future<void> bulk_async(executor_type& ex, Function f, shape_type shape)
    {
      return ex.bulk_async(f, shape);
      
      // XXX default implementation if member above is missing:
      //return bulk_async(ex, [=](index_type index, const shape_type&)
      //{
      //  f(index);
      //},
      //shape, shape
      //);
    }

    template<class Function, class T>
    static void bulk_invoke(executor_type& ex, Function f, size_t n, T shared_arg)
    {
      // XXX default implementation if ex.bulk_invoke(f,n,shared_arg) is missing:
      return bulk_async(ex, f, n, shared_arg).wait();
    }

    template<class Function>
    static void bulk_invoke(executor_type& ex, Function f, size_t n)
    {
      // XXX default implementation if ex.bulk_invoke(f,n) is missing:
      return bulk_async(ex, f, n).wait();
    }
};


template<class Executor, class Function, class... Args>
std::future<void> bulk_async(Executor& ex,
                             typename executor_traits<Executor>::shape_type shape,
                             Function&& f,
                             Args&&... args)
{
  auto g = std::bind(std::forward<Function>(f), std::placeholders::_1, std::forward<Args>(args)...);
  return executor_traits<Executor>::bulk_async(ex, f, shape);
}


template<class Executor, class Function, class... Args>
void bulk_invoke(Executor& ex,
                 typename executor_traits<Executor>::shape_type shape,
                 Function&& f,
                 Args&&... args)
{
  auto g = std::bind(std::forward<Function>(f), std::placeholders::_1, std::forward<Args>(args)...);
  return executor_traits<Executor>::bulk_invoke(ex, f, shape);
}


}

