#pragma once

#include <type_traits>
#include <barrier>
#include <functional>
#include <iostream>
#include <coordinate>
#include "tuple_tail.hpp"

namespace std
{


template<class ExecutionGroup, class OtherChild>
struct __rebind_execution_group
{
  typedef typename ExecutionGroup::template rebind<OtherChild>::other type;
};


template<template<class, class...> class ExecutionGroup, class OriginalChild, class... T, class OtherChild>
struct __rebind_execution_group<ExecutionGroup<OriginalChild, T...>, OtherChild>
{
  typedef ExecutionGroup<OtherChild, T...> type;
};


template<typename T>
  struct __has_child_type
{
  typedef char yes_type;
  typedef int  no_type;
  template<typename S> static yes_type test(typename S::child_type *);
  template<typename S> static no_type  test(...);
  static bool const value = sizeof(test<T>(0)) == sizeof(yes_type);
  typedef std::integral_constant<bool, value> type;
};


template<typename T>
struct __child_type
{
  typedef typename T::child_type type;
};


template<typename T>
struct __identity
{
  typedef T type;
};


template<bool b, typename T, typename F>
struct __lazy_conditional;


template<typename T, typename F>
struct __lazy_conditional<true,T,F>
{
  typedef typename T::type type;
};


template<typename T, typename F>
struct __lazy_conditional<false,T,F>
{
  typedef typename F::type type;
};


// XXX consider whether there should be derived-from relationships between these
struct sequential_execution_tag {};
struct concurrent_execution_tag {};
struct parallel_execution_tag {};
struct vector_execution_tag {};


template<class ExecutionGroup>
class execution_group_traits
{
  private:
    template<class T>
    static constexpr size_t depth_impl(T, std::false_type has_child)
    {
      return 0;
    }

    template<class T>
    static constexpr size_t depth_impl(T, std::true_type has_child)
    {
      return 1 + execution_group_traits<child_type>::depth;
    }

  public:
    typedef ExecutionGroup                               group_type;
    typedef typename ExecutionGroup::execution_category  execution_category;
    
    // XXX this should be the type of declval<group_type>.param()
    typedef typename ExecutionGroup::param_type          param_type;

    // XXX this should be the type of declval<group_type>.domain()
    typedef typename ExecutionGroup::domain_type         domain_type;

    // XXX this should be the type of declval<group_type>.index()
    typedef typename ExecutionGroup::index_type          index_type;

    // XXX this should be the type of declval<group_type>.size()
    typedef typename ExecutionGroup::size_type           size_type;

    typedef typename __lazy_conditional<
      __has_child_type<group_type>::value,
      __child_type<group_type>,
      __identity<void>
    >::type                                              child_type;

    // XXX consider renaming to nesting_depth or grouping_depth
    //     to emphasize that agents have depth 0
    // XXX alternatively, make it illegal to use execution_group_traits on non-groups
    constexpr static size_t depth = depth_impl(0, typename __has_child_type<group_type>::type());
    
    template<class OtherChild>
    using rebind_execution_group = typename __rebind_execution_group<group_type, OtherChild>::type;

    template<class ParamTuple, class IndexTuple>
    static group_type make(const ParamTuple& params, const IndexTuple& indices)
    {
      return group_type(params, indices);
    }

    template<class OtherChild>
    static rebind_execution_group<OtherChild> rebind_child(const group_type& g, OtherChild&& child)
    {
      return rebind_execution_group<OtherChild>(g.param(), g.index(), std::move(child));
    }

    // XXX rethink whether we need both reindex and something which links two groups, possibly with new indices
    // XXX shouldn't we reindex the entire tree at the same time?
    // XXX shouldn't we recieve a tuple like make()?
    static void reindex(group_type& g, index_type new_index)
    {
      g.reindex(new_index);
    }

    static domain_type domain(const param_type& params)
    {
      return params.domain();
    }
};


class agent
{
  public:
    using execution_category = sequential_execution_tag;
    struct param_type {};

    // XXX what should an agent's domain be?
    typedef void      domain_type;
    typedef size_t    size_type;
    typedef size_type index_type;

    // XXX is size() necessary?
    //     I don't think we ever use it
    size_type size() const { return 1; }

    size_type index() const { return index_; }

    agent(agent&& other) = default;

    param_type param() const
    {
      return param_type();
    }

  private:
    friend class execution_group_traits<agent>;

    agent(const std::tuple<param_type>&, const std::tuple<size_type>& index)
      : index_(std::get<0>(index))
    {}

    void reindex(index_type index)
    {
      index_ = index;
    }

    index_type index_;
};


template<class ExecutionCategory, class ExecutionGroup>
class __execution_group_base
{
  public:
    using execution_category = ExecutionCategory; 
    typedef ExecutionGroup                                                        child_type;
    typedef regular_grid<typename execution_group_traits<child_type>::index_type> domain_type;
    typedef typename domain_type::size_type                                       size_type;

    // XXX need to generalize __execution_group_base for higher dimensions
    typedef size_type                                                             index_type;

    class param_type
    {
      public:
        param_type(const param_type& other)
          : domain_(other.domain_)
        {}

        param_type(const domain_type& d)
          : domain_(d)
        {}

        param_type(index_type min, index_type max)
          : param_type(domain_type(min,max))
        {}

        param_type(size_type n)
          : param_type(size_type{0}, n)
        {}

        const domain_type& domain() const
        {
          return domain_;
        }

      private:
        domain_type domain_;
    };

    param_type param() const
    {
      return param_type(domain());
    }

    const domain_type& domain() const { return domain_; }
    size_type size() const { return domain().size(); }
    index_type index() const { return index_; }
    ExecutionGroup &child() { return child_; }
    const ExecutionGroup &child() const { return child_; }

  private:
    template<class> friend class execution_group_traits;

    index_type  index_;
    domain_type domain_;
    child_type  child_;

    void reindex(index_type index)
    {
      index_ = index;
    }

  protected:
    typedef execution_group_traits<child_type> child_traits;

    template<class Param>
    __execution_group_base(const Param& params, size_type index, child_type&& chld)
      : index_(index),
        domain_(params.domain()),
        child_(std::move(chld))
    {}

    template<class ParamTuple, class IndexTuple>
    __execution_group_base(const ParamTuple& params, const IndexTuple& indices)
      : __execution_group_base(std::get<0>(params),
                               std::get<0>(indices),
                               child_traits::make(tuple_tail(params), tuple_tail(indices)))
    {}
};


template<class ExecutionGroup = std::agent>
class sequential_group : public __execution_group_base<sequential_execution_tag, ExecutionGroup>
{
  public:
    using __execution_group_base<sequential_execution_tag, ExecutionGroup>::__execution_group_base;
};


template<class ExecutionGroup = std::agent>
class parallel_group : public __execution_group_base<parallel_execution_tag, ExecutionGroup>
{
  public:
    using __execution_group_base<parallel_execution_tag, ExecutionGroup>::__execution_group_base;
};


template<class ExecutionGroup = std::agent>
class concurrent_group : public __execution_group_base<concurrent_execution_tag, ExecutionGroup>
{
  private:
    typedef __execution_group_base<concurrent_execution_tag, ExecutionGroup> super_t;

  public:
    typedef typename super_t::domain_type domain_type;
    typedef typename super_t::index_type  index_type;
    typedef typename super_t::size_type   size_type;

    class param_type : public super_t::param_type
    {
      public:
        param_type(const param_type &other)
          : param_type(other.domain(), other.barrier())
        {}

        param_type(const domain_type& domain, std::reference_wrapper<std::barrier> barrier)
          : super_t::param_type(domain),
            barrier_(barrier)
        {}

        param_type(index_type min, index_type max, std::reference_wrapper<std::barrier> barrier)
          : param_type(domain_type(min,max), barrier)
        {}

        param_type(size_type n, std::reference_wrapper<std::barrier> barrier)
          : param_type(size_type{0}, n, barrier)
        {}

        std::reference_wrapper<std::barrier> barrier() const
        {
          return barrier_;
        }

      private:
        std::reference_wrapper<std::barrier> barrier_;
    };

    param_type param() const
    {
      return param_type(super_t::domain(), barrier_);
    }

    template<class OtherGroup>
    struct rebind
    {
      typedef concurrent_group<OtherGroup> other;
    };

    // XXX consider making this function const
    void wait()
    {
      barrier_.count_down_and_wait();
    }

  private:
    template<class> friend class execution_group_traits;

    template<class ParamTuple, class IndexTuple>
    concurrent_group(const ParamTuple& params, const IndexTuple& indices)
      : super_t(params, indices),
        barrier_(std::get<0>(params).barrier())
    {}

    template<class Param>
    concurrent_group(const Param& params, index_type index, ExecutionGroup&& chld)
      : super_t(params, index, std::move(chld)),
        barrier_(params.barrier())
    {}

    std::barrier &barrier_;
};


template<class T>
struct __has_child_impl
{
  typedef char yes_type;
  struct no_type {char x[2];};

  template<class U> static yes_type test(decltype(&U::child));
  template<class U> static no_type  test(...);

  public:
    const static bool value = sizeof(test<T>(0)) == sizeof(yes_type);
};


template<class T>
struct __has_child :
  std::integral_constant<
    bool,
    __has_child_impl<T>::value
  >
{};


}

