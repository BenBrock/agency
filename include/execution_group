#pragma once

#include <type_traits>
#include <barrier>
#include <functional>
#include <iostream>
#include <coordinate>
#include <execution_categories>
#include <__tuple_tail>

namespace std
{


template<class ExecutionGroup, class OtherChild>
struct __rebind_execution_group
{
  typedef typename ExecutionGroup::template rebind<OtherChild>::other type;
};


template<template<class, class...> class ExecutionGroup, class OriginalChild, class... T, class OtherChild>
struct __rebind_execution_group<ExecutionGroup<OriginalChild, T...>, OtherChild>
{
  typedef ExecutionGroup<OtherChild, T...> type;
};


template<typename T>
  struct __has_child_type
{
  typedef char yes_type;
  typedef int  no_type;
  template<typename S> static yes_type test(typename S::child_type *);
  template<typename S> static no_type  test(...);
  static bool const value = sizeof(test<T>(0)) == sizeof(yes_type);
  typedef std::integral_constant<bool, value> type;
};


template<typename T>
struct __child_type
{
  typedef typename T::child_type type;
};


template<typename T>
struct __identity
{
  typedef T type;
};


template<typename>
struct __sfinae
{
  using type = void;
};


template<typename T, typename = void>
struct __has_domain : std::false_type {};


template<typename T>
struct __has_domain<
  T,
  typename __sfinae<decltype(std::declval<T>().domain())>::type
> : std::true_type
{};


template<typename T>
struct __domain_type
{
  using type = typename T::domain_type;
};


template<bool b, typename T, typename F>
struct __lazy_conditional
{
  using type = typename T::type;
};


template<typename T, typename F>
struct __lazy_conditional<false,T,F>
{
  using type = typename F::type;
};


template<class ExecutionGroup>
class execution_group_traits
{
  private:
    template<class T>
    static constexpr size_t depth_impl(T, std::false_type has_child)
    {
      return 0;
    }

    template<class T>
    static constexpr size_t depth_impl(T, std::true_type has_child)
    {
      return 1 + execution_group_traits<child_type>::depth;
    }

  public:
    using group_type = ExecutionGroup;

    using execution_category = typename group_type::execution_category;
    
    using param_type = typename group_type::param_type;

    using domain_type = typename __lazy_conditional<
      __has_domain<group_type>::value,
      __domain_type<group_type>,
      __identity<void>
    >::type;

    using index_type = decltype(std::declval<group_type>().index());

    using size_type = decltype(std::declval<group_type>().size());

    typedef typename __lazy_conditional<
      __has_child_type<group_type>::value,
      __child_type<group_type>,
      __identity<void>
    >::type                                              child_type;

    // XXX consider renaming to nesting_depth or grouping_depth
    //     to emphasize that agents have depth 0
    // XXX alternatively, make it illegal to use execution_group_traits on non-groups
    constexpr static size_t depth = depth_impl(0, typename __has_child_type<group_type>::type());
    
    template<class OtherChild>
    using rebind_execution_group = typename __rebind_execution_group<group_type, OtherChild>::type;

    template<class ParamTuple, class IndexTuple>
    static group_type make_group(const ParamTuple& params, const IndexTuple& indices)
    {
      return group_type(params, indices);
    }

    template<class OtherChild>
    static rebind_execution_group<OtherChild> rebind_child(group_type&& g, OtherChild&& child)
    {
      return rebind_execution_group<OtherChild>(std::move(g), std::move(child));
    }

    // XXX rethink whether we need both reindex and something which links two groups, possibly with new indices
    // XXX shouldn't we reindex the entire tree at the same time?
    // XXX shouldn't we recieve a tuple of indices like make_group()?
    static void reindex(group_type& g, index_type new_index)
    {
      g.reindex(new_index);
    }

    static domain_type domain(const param_type& params)
    {
      return params.domain();
    }

  private:
    template<typename T>
    struct child_param_tuple_impl
    {
      using child_type = typename execution_group_traits<T>::child_type;
      using type = typename execution_group_traits<child_type>::param_tuple_type;
    };


    typedef typename __lazy_conditional<
      __has_child_type<group_type>::value,
      child_param_tuple_impl<group_type>,
      __identity<std::tuple<>>
    >::type child_param_tuple_type;


    template<class... Params>
    static std::tuple<param_type, Params...> param_tuple_impl(const param_type& head_param, const std::tuple<Params...>& tail_params)
    {
      return std::tuple_cat(std::make_tuple(head_param), tail_params);
    }

    template<class T>
    static child_param_tuple_type child_param_tuple(T, const group_type& g, std::false_type)
    {
      return std::tuple<>();
    }

    template<class T>
    static child_param_tuple_type child_param_tuple(T, const group_type& g, std::true_type)
    {
      return execution_group_traits<child_type>::child_param_tuple(g.child());
    }


  public:
    // returns a tuple containing each node's param, beginning at the root of the hierarchy
    // e.g. make_tuple(g.param(), g.child().param(), g.child().child().param(), ...)
    static auto param_tuple(const group_type& g)
      -> decltype(param_tuple_impl(g.param(), child_param_tuple(0, g, typename __has_child_type<group_type>::type())))
    {
      return param_tuple_impl(g.param(), child_param_tuple(0, g, typename __has_child_type<group_type>::type()));
    }

    using param_tuple_type = decltype(param_tuple(std::declval<group_type>()));
};


class agent
{
  public:
    using execution_category = sequential_execution_tag;
    struct param_type {};

    typedef size_t    size_type;
    typedef size_type index_type;

    // XXX is size() necessary?
    //     I don't think we ever use it
    size_type size() const { return 1; }

    size_type index() const { return index_; }

    agent(agent&& other) = default;

    param_type param() const
    {
      return param_type();
    }

  private:
    friend class execution_group_traits<agent>;

    agent(const std::tuple<param_type>&, const std::tuple<size_type>& index)
      : index_(std::get<0>(index))
    {}

    void reindex(index_type index)
    {
      index_ = index;
    }

    index_type index_;
};


template<class ExecutionCategory, class ExecutionGroup>
class __execution_group_base
{
  public:
    using execution_category = ExecutionCategory; 
    typedef ExecutionGroup                                                        child_type;
    typedef regular_grid<typename execution_group_traits<child_type>::index_type> domain_type;
    typedef typename domain_type::size_type                                       size_type;

    // XXX need to generalize __execution_group_base for higher dimensions
    // XXX shouldn't this be the index_type of domain_type?
    typedef size_type                                                             index_type;

    class param_type
    {
      public:
        // copy from related param_types
        // this allows us to copy from e.g.
        // concurrent_agent<>::param_type -> concurrent_agent<sequential_agent<>>::param_type
        // the types aren't interoperable otherwise
        template<class OtherParamType>
        param_type(const OtherParamType& other)
          : domain_(other.domain())
        {}

        param_type(const param_type& other)
          : domain_(other.domain_)
        {}

        param_type(const domain_type& d)
          : domain_(d)
        {}

        param_type(index_type min, index_type max)
          : param_type(domain_type(min,max))
        {}

        param_type(size_type n)
          : param_type(size_type{0}, n)
        {}

        const domain_type& domain() const
        {
          return domain_;
        }

      private:
        domain_type domain_;
    };

    param_type param() const
    {
      return param_type(domain());
    }

    const domain_type& domain() const { return domain_; }
    size_type size() const { return domain().size(); }
    index_type index() const { return index_; }
    ExecutionGroup &child() { return child_; }
    const ExecutionGroup &child() const { return child_; }

  private:
    template<class> friend class execution_group_traits;

    domain_type domain_;
    index_type  index_;
    child_type  child_;

    void reindex(index_type index)
    {
      index_ = index;
    }

  protected:
    typedef execution_group_traits<child_type> child_traits;

    // XXX three constructors is too many
    template<class Param>
    __execution_group_base(const Param &params, index_type index, child_type&& chld)
      : domain_(params.domain()),
        index_(index),
        child_(std::move(chld))
    {}

    // the following two constructors are used by execution_group_traits

    // XXX OtherConcurrentGroup must be a descendant of __execution_group_base<ExecutionCategory,OtherGroup>
    template<class OtherExecutionGroup>
    __execution_group_base(OtherExecutionGroup&& group, child_type&& chld)
      : __execution_group_base(group.param(), group.index(), std::move(chld))
    {}

    // XXX this ought to be the only constructor we require
    // XXX eliminate the other two constructors we we've revamped __nested_execution_policy to
    //     inherit from __basic_execution_policy
    // XXX find a way to make this not a template
    template<class ParamTuple, class IndexTuple>
    __execution_group_base(const ParamTuple& params, const IndexTuple& indices)
      : __execution_group_base(std::get<0>(params),
                               std::get<0>(indices),
                               child_traits::make_group(tuple_tail(params), tuple_tail(indices)))
    {}
};


template<class ExecutionGroup = std::agent>
class sequential_agent : public __execution_group_base<sequential_execution_tag, ExecutionGroup>
{
  private:
    template<class> friend class execution_group_traits;

  protected:
    using __execution_group_base<sequential_execution_tag, ExecutionGroup>::__execution_group_base;
};


template<class ExecutionGroup = std::agent>
class parallel_agent : public __execution_group_base<parallel_execution_tag, ExecutionGroup>
{
  private:
    template<class> friend class execution_group_traits;

  protected:
    using __execution_group_base<parallel_execution_tag, ExecutionGroup>::__execution_group_base;
};


template<class ExecutionGroup = std::agent>
class vector_agent : public __execution_group_base<vector_execution_tag, ExecutionGroup>
{
  private:
    template<class> friend class execution_group_traits;

  protected:
    using __execution_group_base<vector_execution_tag, ExecutionGroup>::__execution_group_base;
};


template<class ExecutionGroup = std::agent>
class concurrent_agent : public __execution_group_base<concurrent_execution_tag, ExecutionGroup>
{
  public:
    void wait() const
    {
      barrier_->count_down_and_wait();
    }

  private:
    using super_t = __execution_group_base<concurrent_execution_tag,ExecutionGroup>;

    template<class> friend class execution_group_traits;

    friend void __set_barrier(concurrent_agent &self, std::barrier *bar)
    {
      self.barrier_ = bar;
    }

    // XXX might be best to make this a shared_ptr
    std::barrier *barrier_;

    template<class OtherExecutionGroup> friend class concurrent_agent;

    // XXX OtherConcurrentGroup must be a descendant of an instance of concurrent_agent<U>
    template<class OtherConcurrentGroup>
    concurrent_agent(OtherConcurrentGroup&& group, typename concurrent_agent::child_type&& chld)
      : super_t(std::move(group), std::move(chld)),
        barrier_(group.barrier_)
    {}

  protected:
    using __execution_group_base<concurrent_execution_tag, ExecutionGroup>::__execution_group_base;
};


}

