#pragma once

#include <tuple>
#include <utility>
#include <type_traits>
#include <__tuple_utility>
#include <coordinate>

namespace std
{


template<class T, size_t N, class Enable = void> struct __rebind_point_size_impl;

template<template<class,size_t> class point, class T, size_t N, size_t M>
struct __rebind_point_size_impl<point<T,N>, M>
{
  using type = point<T,M>;
};


template<class T, size_t N>
struct __rebind_point_size_impl<T, N,
  typename std::enable_if<
    std::is_arithmetic<T>::value
  >::type
>
{
  using type = std::point<T,N>;
};


template<class T, size_t N>
struct __rebind_point_size
{
  using type = typename __rebind_point_size_impl<T,N>::type;
};

template<class T, size_t N>
using __rebind_point_size_t = typename __rebind_point_size<T,N>::type;


template<class T, class Enable = void>
struct __point_size : std::tuple_size<T> {};


template<class T>
struct __point_size<
  T,
  typename std::enable_if<
    std::is_arithmetic<T>::value
  >::type
>
  : std::integral_constant<std::size_t, 1>
{};


// reduces the dimensionality of x by eliding the last dimension
// and multiplying the second-to-last dimension by the last 
template<class Point>
__rebind_point_size_t<
  Point,
  __point_size<Point>::value - 1
> __project_shape(const Point& x)
{
  using result_type = __rebind_point_size_t<Point,std::tuple_size<Point>::value-1>;

  auto last = std::get<std::tuple_size<result_type>::value>(x);

  auto result = __tu::make_from_tuple<result_type>(__tu::tuple_drop<1>(x));

  std::get<std::tuple_size<result_type>::value-1>(result) *= last;

  return result;
}


// increases the dimensionality of x
// by appending a dimension (and setting it to 1)
template<class Point>
__rebind_point_size_t<
  Point,
  __point_size<Point>::value + 1
> __lift_shape(const Point& x)
{
  // x could be a scalar, so create an intermediate which is at least a 1-element tuple
  using intermediate_type = __rebind_point_size_t<Point,__point_size<Point>::value>;
  intermediate_type intermediate{x};

  using result_type = __rebind_point_size_t<Point,__point_size<Point>::value + 1>;

  return __tu::make_from_tuple<result_type>(__tu::tuple_append(intermediate, 1));
}


// __shape_cast is recursive and has various overloads
// declare them here before their definitions

// Scalar -> Scalar (base case)
template<class ToShape, class FromShape>
typename std::enable_if<
  (__point_size<ToShape>::value == __point_size<FromShape>::value) &&
  (__point_size<ToShape>::value == 1),
  ToShape
>::type
  __shape_cast(const FromShape& x);


// recursive case for casting two shapes of equal size (recursive case)
template<class ToShape, class FromShape>
typename std::enable_if<
  (__point_size<ToShape>::value == __point_size<FromShape>::value) &&
  (__point_size<ToShape>::value > 1),
  ToShape
>::type
  __shape_cast(const FromShape& x);


// downcast (recursive)
template<class ToShape, class FromShape>
typename std::enable_if<
  (__point_size<ToShape>::value < __point_size<FromShape>::value),
  ToShape
>::type
  __shape_cast(const FromShape& x);


// upcast (recursive)
template<class ToShape, class FromShape>
typename std::enable_if<
  (__point_size<ToShape>::value > __point_size<FromShape>::value),
  ToShape
>::type
  __shape_cast(const FromShape& x);


// definitions of __shape_cast follow


// terminal case for casting shapes of size 1
template<class ToShape, class FromShape>
typename std::enable_if<
  (__point_size<ToShape>::value == __point_size<FromShape>::value) &&
  (__point_size<ToShape>::value == 1),
  ToShape
>::type
  __shape_cast(const FromShape& x)
{
  // x might not be a tuple, but instead a scalar type
  // to ensure we can get the 0th value from x in a uniform way, lift it first
  return ToShape{std::get<0>(__lift_shape(x))};
}

struct __shape_cast_functor
{
  template<class ToShape, class FromShape>
  auto operator()(const ToShape&, const FromShape& x)
    -> decltype(
         __shape_cast<ToShape>(x)
       )
  {
    return __shape_cast<ToShape>(x);
  }
};


template<class T>
struct __make
{
  template<class... Args>
  T operator()(Args&&... args)
  {
    return T{std::forward<Args>(args)...};
  }
};


// recursive case for casting to a shape of equal size
template<class ToShape, class FromShape>
typename std::enable_if<
  (__point_size<ToShape>::value == __point_size<FromShape>::value) &&
  (__point_size<ToShape>::value > 1),
  ToShape
>::type
  __shape_cast(const FromShape& x)
{
  return __tuple_map_with_make(__shape_cast_functor{}, __make<ToShape>{}, ToShape{}, x);
}


// recursive case for casting to a lower dimensional shape
template<class ToShape, class FromShape>
typename std::enable_if<
  (__point_size<ToShape>::value < __point_size<FromShape>::value),
  ToShape
>::type
  __shape_cast(const FromShape& x)
{
  return __shape_cast<ToShape>(__project_shape(x));
}


// recursive case for casting to a higher dimensional shape
template<class ToShape, class FromShape>
typename std::enable_if<
  (__point_size<ToShape>::value > __point_size<FromShape>::value),
  ToShape
>::type
  __shape_cast(const FromShape& x)
{
  return __shape_cast<ToShape>(__lift_shape(x));
}


} // end std

