#pragma once

#include <type_traits>
#include <barrier>
#include <functional>
#include <iostream>
#include <coordinate>
#include <execution_categories>
#include <__tuple_tail>
#include <__type_traits>

namespace std
{


__DEFINE_HAS_NESTED_TYPE(__has_child_type, child_type);
__DEFINE_HAS_NESTED_TYPE(__has_index_param_type, index_param_type);
__DEFINE_HAS_NESTED_TYPE(__has_shared_param_type, shared_param_type);


template<class ExecutionAgent>
class execution_agent_traits
{
  private:
    template<class T>
    static constexpr size_t depth_impl(T, std::false_type has_child)
    {
      return 1;
    }

    template<class T>
    static constexpr size_t depth_impl(T, std::true_type has_child)
    {
      return 1 + execution_agent_traits<child_type>::depth;
    }

  public:
    using agent_type = ExecutionAgent;
    using execution_category = typename agent_type::execution_category;
    using param_type = typename agent_type::param_type;
    using domain_type = decltype(std::declval<agent_type>().domain());
    using index_type = decltype(std::declval<agent_type>().index());
    using size_type = decltype(std::declval<agent_type>().group_size());

    static domain_type domain(const param_type& params)
    {
      return params.domain();
    }

  private:
    template<class T>
    struct agent_index_param
    {
      using type = typename T::index_param_type;
    };

  public:
    using index_param_type = typename __lazy_conditional<
      __has_index_param_type<agent_type>::value,
      agent_index_param<agent_type>,
      __identity<index_type>
    >::type;

  private:
    template<class T>
    struct agent_shared_param
    {
      using type = typename T::shared_param_type;
    };

  public:
    using shared_param_type = typename __lazy_conditional<
      __has_shared_param_type<agent_type>::value,
      agent_shared_param<agent_type>,
      __identity<void>
    >::type;

    using has_shared_param_type = typename std::conditional<
      std::is_same<void, shared_param_type>::value,
      std::false_type,
      std::true_type
    >::type;

  private:
    template<class T>
    struct agent_child
    {
      using type = typename T::child_type;
    };

  public:
    typedef typename __lazy_conditional<
      __has_child_type<agent_type>::value,
      agent_child<agent_type>,
      __identity<void>
    >::type child_type;

    // XXX consider renaming this
    constexpr static size_t depth = depth_impl(0, typename __has_child_type<agent_type>::type());

    // XXX this really shouldn't be a template
    template<class... SharedParamType>
    static agent_type make_agent(const param_type& param, const index_param_type& index, SharedParamType&... shared_param)
    {
      return agent_type(param, index, shared_param...);
    }

    // XXX this really shouldn't be a template
    template<class... SharedParamType>
    static shared_param_type shared_param(const param_type& param)
    {
      return shared_param_type(param);
    }
};


template<class ExecutionCategory>
class __basic_execution_agent
{
  public:
    using execution_category = ExecutionCategory; 

    typedef std::size_t                                                           index_type;
    typedef regular_grid<index_type>                                              domain_type;
    typedef typename domain_type::size_type                                       size_type;

    class param_type
    {
      public:
        param_type(const param_type& other)
          : domain_(other.domain_)
        {}

        param_type(const domain_type& d)
          : domain_(d)
        {}

        param_type(index_type min, index_type max)
          : param_type(domain_type(min,max))
        {}

        param_type(size_type n)
          : param_type(size_type{0}, n)
        {}

        const domain_type& domain() const
        {
          return domain_;
        }

      private:
        domain_type domain_;
    };

    param_type param() const
    {
      return param_type(domain());
    }

    const domain_type& domain() const { return domain_; }
    size_type group_size() const { return domain().size(); }
    index_type index() const { return index_; }

  private:
    template<class> friend class execution_agent_traits;

    domain_type domain_;
    index_type  index_;

  protected:
    __basic_execution_agent(const param_type& param, index_type index)
      : domain_(param.domain()),
        index_(index)
    {}
};


using sequential_agent = __basic_execution_agent<std::sequential_execution_tag>;


using parallel_agent = __basic_execution_agent<std::parallel_execution_tag>;


using vector_agent = __basic_execution_agent<std::vector_execution_tag>;


// XXX may wish to give __basic_execution_agent a shared_param template parameter defaulting to void
class concurrent_agent : public __basic_execution_agent<concurrent_execution_tag>
{
  private:
    using super_t = __basic_execution_agent<concurrent_execution_tag>;

  public:
    void wait() const
    {
      barrier_.count_down_and_wait();
    }

    struct shared_param_type
    {
      shared_param_type(const typename super_t::param_type& param)
        : count_(param.domain().size()),
          barrier_(count_)
      {}

      shared_param_type(const shared_param_type& other)
        : count_(other.count_),
          barrier_(count_)
      {}

      int count_;
      std::barrier barrier_;
    };

  private:
    template<class> friend class execution_agent_traits;

    std::barrier &barrier_;

  protected:
    concurrent_agent(const param_type& param, index_type index, shared_param_type& shared_param)
      : super_t(param, index),
        barrier_(shared_param.barrier_)
    {}
};


// XXX may wish not to inherit from ParentAgent
// XXX need to give this guy a shared_param_type if either the parent or child have one
//     and also modulate the form of the constructor depending on whether it has a shared_param_type
template<class ParentAgent, class ChildAgent>
class __execution_group : public ParentAgent
{
  private:
    using super_t = ParentAgent;

  public:
    using execution_category = std::nested_execution_tag<
      typename execution_agent_traits<ParentAgent>::execution_category,
      typename execution_agent_traits<ChildAgent>::execution_category
    >;

    using child_type = ChildAgent;

    using param_type = std::tuple<
      typename execution_agent_traits<ParentAgent>::param_type,
      typename execution_agent_traits<ChildAgent>::param_type
    >;

    class index_param_type
    {
      public:
        template<class... Indices>
        index_param_type(typename execution_agent_traits<ParentAgent>::index_param_type index,
                         Indices... descendent_indices)
          : parent_index_param_(index),
            child_index_param_(descendent_indices...)
        {}

      private:
        typename execution_agent_traits<ParentAgent>::index_param_type parent_index_param_;
        typename execution_agent_traits<ChildAgent>::index_param_type child_index_param_;
    };

    child_type& child()
    {
      return child_;
    }

    const child_type& child() const
    {
      return child_;
    }

  private:
    template<class> friend class execution_agent_traits;

    child_type child_;

  protected:
    __execution_group(const param_type& param, const index_param_type& index)
      : super_t(std::get<0>(param), std::get<0>(index)),
        child_(std::get<1>(param), std::get<1>(index))
    {}

    // XXX eliminate this
    __execution_group(ParentAgent&& parent, ChildAgent&& child)
      : super_t(std::move(parent)),
        child_(std::move(child))
    {}

    // XXX eliminate this
    template<class P, class C>
    friend __execution_group<P,C> __nest_agents(P&& parent, C&& child);
};


template<class ParentAgent, class ChildAgent>
__execution_group<ParentAgent,ChildAgent> __nest_agents(ParentAgent&& parent, ChildAgent&& child)
{
  return __execution_group<ParentAgent,ChildAgent>(std::move(parent), std::move(child));
}


template<class ChildAgent>
using sequential_group = __execution_group<sequential_agent, ChildAgent>;


template<class ChildAgent>
using parallel_group = __execution_group<parallel_agent, ChildAgent>;


template<class ChildAgent>
using vector_group = __execution_group<vector_agent, ChildAgent>;


template<class ChildAgent>
using concurrent_group = __execution_group<concurrent_agent, ChildAgent>;


}

