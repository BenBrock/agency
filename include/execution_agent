#pragma once

#include <type_traits>
#include <barrier>
#include <functional>
#include <iostream>
#include <coordinate>
#include <execution_categories>
#include <__tuple_tail>

namespace std
{


template<class ExecutionAgent, class OtherChild>
struct __rebind_execution_agent
{
  typedef typename ExecutionAgent::template rebind<OtherChild>::other type;
};


template<template<class, class...> class ExecutionAgent, class OriginalChild, class... T, class OtherChild>
struct __rebind_execution_agent<ExecutionAgent<OriginalChild, T...>, OtherChild>
{
  typedef ExecutionAgent<OtherChild, T...> type;
};


template<typename T>
  struct __has_child_type
{
  typedef char yes_type;
  typedef int  no_type;
  template<typename S> static yes_type test(typename S::child_type *);
  template<typename S> static no_type  test(...);
  static bool const value = sizeof(test<T>(0)) == sizeof(yes_type);
  typedef std::integral_constant<bool, value> type;
};


template<typename T>
struct __child_type
{
  typedef typename T::child_type type;
};


template<typename T>
struct __identity
{
  typedef T type;
};


template<typename>
struct __sfinae
{
  using type = void;
};


template<typename T, typename = void>
struct __has_domain : std::false_type {};


template<typename T>
struct __has_domain<
  T,
  typename __sfinae<decltype(std::declval<T>().domain())>::type
> : std::true_type
{};


template<typename T>
struct __domain_type
{
  using type = typename T::domain_type;
};


template<bool b, typename T, typename F>
struct __lazy_conditional
{
  using type = typename T::type;
};


template<typename T, typename F>
struct __lazy_conditional<false,T,F>
{
  using type = typename F::type;
};


// XXX eliminate this
struct rebind_child_tag {};


template<class ExecutionAgent>
class execution_agent_traits
{
  private:
    template<class T>
    static constexpr size_t depth_impl(T, std::false_type has_child)
    {
      return 1;
    }

    template<class T>
    static constexpr size_t depth_impl(T, std::true_type has_child)
    {
      return 1 + execution_agent_traits<child_type>::depth;
    }

  public:
    using agent_type = ExecutionAgent;

    using execution_category = typename agent_type::execution_category;
    
    using param_type = typename agent_type::param_type;

    using domain_type = typename __lazy_conditional<
      __has_domain<agent_type>::value,
      __domain_type<agent_type>,
      __identity<void>
    >::type;

    using index_type = decltype(std::declval<agent_type>().index());

    using size_type = decltype(std::declval<agent_type>().group_size());

    typedef typename __lazy_conditional<
      __has_child_type<agent_type>::value,
      __child_type<agent_type>,
      __identity<void>
    >::type                                              child_type;

    // XXX consider renaming to nesting_depth or grouping_depth
    //     to emphasize that agents have depth 0
    // XXX alternatively, make it illegal to use execution_group_traits on non-groups
    constexpr static size_t depth = depth_impl(0, typename __has_child_type<agent_type>::type());
    
    template<class OtherChild>
    using rebind = typename __rebind_execution_agent<agent_type, OtherChild>::type;

    template<class ParamTuple, class IndexTuple>
    static agent_type make_agent(const ParamTuple& params, const IndexTuple& indices)
    {
      return agent_type(params, indices);
    }

    // XXX eliminate this
    template<class OtherChild>
    static rebind<OtherChild> rebind_child(agent_type&& g, OtherChild&& child)
    {
      return rebind<OtherChild>(rebind_child_tag(), std::move(g), std::move(child));
    }

    static domain_type domain(const param_type& params)
    {
      return params.domain();
    }

  private:
    template<typename T>
    struct child_param_tuple_impl
    {
      using child_type = typename execution_agent_traits<T>::child_type;
      using type = typename execution_agent_traits<child_type>::param_tuple_type;
    };


    typedef typename __lazy_conditional<
      __has_child_type<agent_type>::value,
      child_param_tuple_impl<agent_type>,
      __identity<std::tuple<>>
    >::type child_param_tuple_type;


    template<class... Params>
    static std::tuple<param_type, Params...> param_tuple_impl(const param_type& head_param, const std::tuple<Params...>& tail_params)
    {
      return std::tuple_cat(std::make_tuple(head_param), tail_params);
    }

    template<class T>
    static child_param_tuple_type child_param_tuple(T, const agent_type& g, std::false_type)
    {
      return std::tuple<>();
    }

    template<class T>
    static child_param_tuple_type child_param_tuple(T, const agent_type& g, std::true_type)
    {
      return execution_agent_traits<child_type>::child_param_tuple(g.child());
    }


  public:
    // returns a tuple containing each node's param, beginning at the root of the hierarchy
    // e.g. make_tuple(g.param(), g.child().param(), g.child().child().param(), ...)
    static auto param_tuple(const agent_type& g)
      -> decltype(param_tuple_impl(g.param(), child_param_tuple(0, g, typename __has_child_type<agent_type>::type())))
    {
      return param_tuple_impl(g.param(), child_param_tuple(0, g, typename __has_child_type<agent_type>::type()));
    }

    using param_tuple_type = decltype(param_tuple(std::declval<agent_type>()));
};


template<class ChildAgent>
class __execution_agent_base_base
{
  public:
    using child_type = ChildAgent;

    child_type& child()
    {
      return child_;
    }

    const child_type& child() const
    {
      return child_;
    }

  protected:
    template<class... Args>
    __execution_agent_base_base(Args&&... args)
      : child_(std::forward<Args>(args)...)
    {}

    child_type child_;
};


template<> 
class __execution_agent_base_base<void>
{
  public:
    template<class... Args>
    __execution_agent_base_base(Args&&...)
    {}
};


template<class ExecutionCategory, class ExecutionAgent>
class __execution_agent_base : public __execution_agent_base_base<ExecutionAgent>
{
  private:
    using super_t = __execution_agent_base_base<ExecutionAgent>;

  public:
    using execution_category = ExecutionCategory; 

    typedef std::size_t                                                           index_type;
    typedef regular_grid<index_type>                                              domain_type;
    typedef typename domain_type::size_type                                       size_type;

    class param_type
    {
      public:
        //// XXX get rid of this
        //// copy from related param_types
        //// this allows us to copy from e.g.
        //// concurrent_agent<>::param_type -> concurrent_agent<sequential_agent<>>::param_type
        //// the types aren't interoperable otherwise
        //template<class OtherParamType>
        //param_type(const OtherParamType& other)
        //  : domain_(other.domain())
        //{}

        param_type(const param_type& other)
          : domain_(other.domain_)
        {}

        param_type(const domain_type& d)
          : domain_(d)
        {}

        param_type(index_type min, index_type max)
          : param_type(domain_type(min,max))
        {}

        param_type(size_type n)
          : param_type(size_type{0}, n)
        {}

        const domain_type& domain() const
        {
          return domain_;
        }

      private:
        domain_type domain_;
    };

    param_type param() const
    {
      return param_type(domain());
    }

    const domain_type& domain() const { return domain_; }
    size_type group_size() const { return domain().size(); }
    index_type index() const { return index_; }

  private:
    template<class> friend class execution_agent_traits;

    domain_type domain_;
    index_type  index_;

  protected:
    // the following two constructors are used by execution_group_traits

    // XXX OtherExecutionAgent must be a descendant of __execution_agent_base<ExecutionCategory,OtherAgent>
    // XXX eliminate this
    // XXX this is used by execution_agent_traits::rebind_child()
    template<class OtherExecutionAgent, class Child>
    __execution_agent_base(rebind_child_tag, OtherExecutionAgent&& agent, Child&& chld)
      : super_t(std::move(chld)),
        domain_(agent.domain()),
        index_(agent.index())
    {}

    // XXX this ought to be the only constructor we require
    // XXX eliminate the other two constructors we we've revamped __nested_execution_policy to
    //     inherit from __basic_execution_policy
    // XXX find a way to make this not a template
    template<class ParamTuple, class IndexTuple>
    __execution_agent_base(const ParamTuple& params, const IndexTuple& indices)
      : super_t(tuple_tail(params), tuple_tail(indices)),
        domain_(std::get<0>(params).domain()),
        index_(std::get<0>(indices))
    {}
};


template<class ExecutionAgent = void>
class sequential_agent : public __execution_agent_base<sequential_execution_tag, ExecutionAgent>
{
  private:
    template<class> friend class execution_agent_traits;

  protected:
    using __execution_agent_base<sequential_execution_tag, ExecutionAgent>::__execution_agent_base;
};


template<class ExecutionAgent = void>
class parallel_agent : public __execution_agent_base<parallel_execution_tag, ExecutionAgent>
{
  private:
    template<class> friend class execution_agent_traits;

  protected:
    using __execution_agent_base<parallel_execution_tag, ExecutionAgent>::__execution_agent_base;
};


template<class ExecutionAgent = void>
class vector_agent : public __execution_agent_base<vector_execution_tag, ExecutionAgent>
{
  private:
    template<class> friend class execution_agent_traits;

  protected:
    using __execution_agent_base<vector_execution_tag, ExecutionAgent>::__execution_agent_base;
};


template<class ExecutionAgent = void>
class concurrent_agent : public __execution_agent_base<concurrent_execution_tag, ExecutionAgent>
{
  public:
    void wait() const
    {
      barrier_->count_down_and_wait();
    }

  private:
    using super_t = __execution_agent_base<concurrent_execution_tag,ExecutionAgent>;

    template<class> friend class execution_agent_traits;

    friend void __set_barrier(concurrent_agent &self, std::barrier *bar)
    {
      self.barrier_ = bar;
    }

    // XXX might be best to make this a shared_ptr
    std::barrier *barrier_;

    template<class OtherExecutionAgent> friend class concurrent_agent;

//    // XXX OtherConcurrentAgent must be a descendant of an instance of concurrent_agent<U>
//    template<class OtherConcurrentAgent>
//    concurrent_agent(OtherConcurrentAgent&& agent, typename concurrent_agent::child_type&& chld)
//      : super_t(std::move(agent), std::move(chld)),
//        barrier_(agent.barrier_)
//    {}

  protected:
    using __execution_agent_base<concurrent_execution_tag, ExecutionAgent>::__execution_agent_base;
};


}

