#pragma once

#include <thread>
#include <vector>
#include <memory>
#include <future>
#include <execution_categories>
#include <algorithm>

namespace std
{


class concurrent_executor
{
  public:
    using execution_category = std::concurrent_execution_tag;

    template<class T, class Function>
    void bulk_add(size_t n, T&& shared_arg, Function f)
    {
      for(size_t i = 0; i < n; ++i)
      {
        std::thread t([=,&shared_arg]
        {
          f(i, shared_arg);
        });

        t.detach();
      }
    }

    template<class Function>
    void bulk_add(size_t n, Function f)
    {
      bulk_add(n, 0, [=](size_t i, int)
      {
        f(i);
      });
    }
};


template<class Function, class... Args>
std::future<void> bulk_async(concurrent_executor& ex, size_t n, Function&& f, Args&&... args)
{
  auto g = std::bind(std::forward<Function>(f), std::placeholders::_1, std::function<Args>(args)...);

  using vector_type = std::vector<std::promise<void>>;

  vector_type promises(n);

  // get a vector of futures
  std::vector<std::future<void>> futures(n);
  std::transform(promises.begin(), promises.end(), futures.begin(), [](std::promise<void>& p)
  {
    return p.get_future();
  });

  // give the promises to the executor and execute the function
  ex.bulk_add(n, std::move(promises), [=](size_t i, vector_type& promises)
  {
    g(i);

    promises[i].set_value();
  });

  return std::when_all(futures.begin(), futures.end());
}


template<class Function, class... Args>
void bulk_invoke(concurrent_executor& ex, size_t n, Function&& f, Args&&... args)
{
  std::bulk_invoke(ex, n, std::bind(std::forward<Function>(f), std::placeholders::_1, std::forward<Args>(args)...)).wait();
}


}

